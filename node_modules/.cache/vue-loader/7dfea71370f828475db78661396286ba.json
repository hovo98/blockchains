{"remainingRequest":"C:\\xampp\\htdocs\\cosmos\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js??vue-loader-options!C:\\xampp\\htdocs\\cosmos\\node_modules\\vue-loader\\lib\\index.js!C:\\xampp\\htdocs\\cosmos\\node_modules\\vue-markdown-loader\\lib\\markdown-compiler.js??ref--16-1!C:\\xampp\\htdocs\\cosmos\\content\\md\\whitepaper-pt.md?vue&type=template&id=0dfeb3a3&","dependencies":[{"path":"C:\\xampp\\htdocs\\cosmos\\content\\md\\whitepaper-pt.md","mtime":1644920968000},{"path":"C:\\xampp\\htdocs\\cosmos\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\xampp\\htdocs\\cosmos\\node_modules\\vue-loader\\lib\\loaders\\templateLoader.js","mtime":499162500000},{"path":"C:\\xampp\\htdocs\\cosmos\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\xampp\\htdocs\\cosmos\\node_modules\\vue-markdown-loader\\lib\\markdown-compiler.js","mtime":1645112455562}],"contextDependencies":[],"result":["var render = function () {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function () {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"section\", [\n      _c(\"h1\", { attrs: { id: \"cosmos\" } }, [_vm._v(\"Cosmos\")]),\n      _c(\"p\", [_vm._v(\"Uma Rede de Distribuição de Ledgers\")]),\n      _c(\"p\", [\n        _vm._v(\"Jae Kwon jae@tendermint.com\"),\n        _c(\"br\"),\n        _vm._v(\"\\nEthan Buchman ethan@tendermint.com\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Para discussões, \"),\n        _c(\"a\", { attrs: { href: \"https://discord.gg/cosmosnetwork\" } }, [\n          _vm._v(\"entre no nosso Matrix\"),\n        ]),\n        _vm._v(\"!\"),\n      ]),\n      _c(\"p\", [\n        _c(\"em\", [\n          _vm._v(\n            \"NOTA: Se você pode ler isso no GitHub, então ainda estamos desenvolvendo este documento ativamente. Por favor, cheque regularmente as atualizações!\"\n          ),\n        ]),\n      ]),\n      _c(\"p\"),\n      _c(\"div\", { staticClass: \"minimal-toc\" }, [\n        _c(\"ul\", [\n          _c(\"li\", [\n            _c(\"a\", { attrs: { href: \"#tendermint\" } }, [_vm._v(\"Tendermint\")]),\n            _c(\"ul\", [\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#validadores\" } }, [\n                  _vm._v(\"Validadores\"),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#consenso\" } }, [_vm._v(\"Consenso\")]),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#clientes-light\" } }, [\n                  _vm._v(\"Clientes Light\"),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#previnindo-ataques\" } }, [\n                  _vm._v(\"Previnindo ataques\"),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#tmsp\" } }, [_vm._v(\"TMSP\")]),\n              ]),\n            ]),\n          ]),\n          _c(\"li\", [\n            _c(\"a\", { attrs: { href: \"#visao-geral-da-cosmos\" } }, [\n              _vm._v(\"Visão Geral da Cosmos\"),\n            ]),\n            _c(\"ul\", [\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#tendermint-bft\" } }, [\n                  _vm._v(\"Tendermint-BFT\"),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#governanca\" } }, [\n                  _vm._v(\"Governança\"),\n                ]),\n              ]),\n            ]),\n          ]),\n          _c(\"li\", [\n            _c(\"a\", { attrs: { href: \"#o-hub-e-as-zonas\" } }, [\n              _vm._v(\"O Hub e as Zonas\"),\n            ]),\n            _c(\"ul\", [\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#o-hub\" } }, [_vm._v(\"O Hub\")]),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#as-zonas\" } }, [_vm._v(\"As Zonas\")]),\n              ]),\n            ]),\n          ]),\n          _c(\"li\", [\n            _c(\"a\", { attrs: { href: \"#comunicacao-inter-blockchain-ibc\" } }, [\n              _vm._v(\"Comunicação Inter-blockchain (IBC)\"),\n            ]),\n          ]),\n          _c(\"li\", [\n            _c(\"a\", { attrs: { href: \"#casos-de-uso\" } }, [\n              _vm._v(\"Casos de Uso\"),\n            ]),\n            _c(\"ul\", [\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#exchange-distribuidas\" } }, [\n                  _vm._v(\"Exchange Distribuídas\"),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\n                  \"a\",\n                  { attrs: { href: \"#pegging-para-outras-criptomoedas\" } },\n                  [_vm._v(\"Pegging para Outras Criptomoedas\")]\n                ),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#ethereum-scaling\" } }, [\n                  _vm._v(\"Ethereum Scaling\"),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#integracao-de-multi-aplicacao\" } }, [\n                  _vm._v(\"Integração de Multi-Aplicação\"),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#reducao-de-particao-de-rede\" } }, [\n                  _vm._v(\"Redução de partição de rede\"),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\n                  \"a\",\n                  {\n                    attrs: { href: \"#sistema-de-resolucao-de-nomes-federados\" },\n                  },\n                  [_vm._v(\"Sistema de Resolução de Nomes Federados\")]\n                ),\n              ]),\n            ]),\n          ]),\n          _c(\"li\", [\n            _c(\"a\", { attrs: { href: \"#emissao-e-incentivos\" } }, [\n              _vm._v(\"Emissão e Incentivos\"),\n            ]),\n            _c(\"ul\", [\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#o-token-atom\" } }, [\n                  _vm._v(\"O Token Atom\"),\n                ]),\n                _c(\"ul\", [\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#levantamento-de-fundos\" } }, [\n                      _vm._v(\"Levantamento de Fundos\"),\n                    ]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#investindo\" } }, [\n                      _vm._v(\"Investindo\"),\n                    ]),\n                  ]),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\n                  \"a\",\n                  { attrs: { href: \"#limitacoes-do-numero-de-validadores\" } },\n                  [_vm._v(\"Limitações do Número de Validadores\")]\n                ),\n              ]),\n              _c(\"li\", [\n                _c(\n                  \"a\",\n                  {\n                    attrs: {\n                      href: \"#tornando-se-um-validador-depois-do-dia-da-genesis\",\n                    },\n                  },\n                  [_vm._v(\"Tornando-se um Validador depois do dia da Genesis\")]\n                ),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#penalidades-para-validadores\" } }, [\n                  _vm._v(\"Penalidades para Validadores\"),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#taxas-de-transacao\" } }, [\n                  _vm._v(\"Taxas de Transação\"),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#incentivando-hackers\" } }, [\n                  _vm._v(\"Incentivando Hackers\"),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#especificacao-de-governanca\" } }, [\n                  _vm._v(\"Específicação de Governança\"),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\n                  \"a\",\n                  { attrs: { href: \"#parametro-de-mudanca-de-proposta\" } },\n                  [_vm._v(\"Parâmetro de Mudança de Proposta\")]\n                ),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#texto-da-proposta\" } }, [\n                  _vm._v(\"Texto da Proposta\"),\n                ]),\n              ]),\n            ]),\n          ]),\n          _c(\"li\", [\n            _c(\"a\", { attrs: { href: \"#roteiro\" } }, [_vm._v(\"Roteiro\")]),\n          ]),\n          _c(\"li\", [\n            _c(\"a\", { attrs: { href: \"#trabalho-relacionado\" } }, [\n              _vm._v(\"Trabalho Relacionado\"),\n            ]),\n            _c(\"ul\", [\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#sistemas-de-consenso\" } }, [\n                  _vm._v(\"Sistemas de Consenso\"),\n                ]),\n                _c(\"ul\", [\n                  _c(\"li\", [\n                    _c(\n                      \"a\",\n                      { attrs: { href: \"#classic-byzantine-fault-tolerance\" } },\n                      [_vm._v(\"Classic Byzantine Fault Tolerance\")]\n                    ),\n                  ]),\n                  _c(\"li\", [\n                    _c(\n                      \"a\",\n                      {\n                        attrs: { href: \"#participacao-delegada-do-bitshares\" },\n                      },\n                      [_vm._v(\"Participação delegada do BitShares\")]\n                    ),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#stellar\" } }, [\n                      _vm._v(\"Stellar\"),\n                    ]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#bitcoinng\" } }, [\n                      _vm._v(\"BitcoinNG\"),\n                    ]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#casper\" } }, [_vm._v(\"Casper\")]),\n                  ]),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#escala-horizontal\" } }, [\n                  _vm._v(\"Escala Horizontal\"),\n                ]),\n                _c(\"ul\", [\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#protocolo-interledger\" } }, [\n                      _vm._v(\"Protocolo Interledger\"),\n                    ]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#sidechains\" } }, [\n                      _vm._v(\"Sidechains\"),\n                    ]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\n                      \"a\",\n                      {\n                        attrs: {\n                          href: \"#esforcos-de-escalabilidade-do-ethereum\",\n                        },\n                      },\n                      [_vm._v(\"Esforços de Escalabilidade do Ethereum\")]\n                    ),\n                    _c(\"ul\", [\n                      _c(\"li\", [\n                        _c(\n                          \"a\",\n                          { attrs: { href: \"#cosmos-vs-ethereum-20-mauve\" } },\n                          [_vm._v(\"Cosmos vs Ethereum 2.0 Mauve\")]\n                        ),\n                      ]),\n                    ]),\n                  ]),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#escala-geral\" } }, [\n                  _vm._v(\"Escala Geral\"),\n                ]),\n                _c(\"ul\", [\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#lightning-network\" } }, [\n                      _vm._v(\"Lightning Network\"),\n                    ]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#segregated-witness\" } }, [\n                      _vm._v(\"Segregated Witness\"),\n                    ]),\n                  ]),\n                ]),\n              ]),\n            ]),\n          ]),\n          _c(\"li\", [\n            _c(\"a\", { attrs: { href: \"#apendice\" } }, [_vm._v(\"Apêndice\")]),\n            _c(\"ul\", [\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#responsabilidade-de-fork\" } }, [\n                  _vm._v(\"Responsabilidade de Fork\"),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#consenso-tendermint\" } }, [\n                  _vm._v(\"Consenso Tendermint\"),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#clientes-leves-do-tendermint\" } }, [\n                  _vm._v(\"Clientes Leves do Tendermint\"),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\n                  \"a\",\n                  { attrs: { href: \"#prevencao-de-ataques-de-longo-alcance\" } },\n                  [_vm._v(\"Prevenção de ataques de longo alcance\")]\n                ),\n              ]),\n              _c(\"li\", [\n                _c(\n                  \"a\",\n                  { attrs: { href: \"#superando-forks-e-ataques-de-censura\" } },\n                  [_vm._v(\"Superando Forks e Ataques de Censura\")]\n                ),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#especificacao-tmsp\" } }, [\n                  _vm._v(\"Especificação TMSP\"),\n                ]),\n                _c(\"ul\", [\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#appendtx\" } }, [\n                      _vm._v(\"AppendTx\"),\n                    ]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#checktx\" } }, [\n                      _vm._v(\"CheckTx\"),\n                    ]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#commit\" } }, [_vm._v(\"Commit\")]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#query\" } }, [_vm._v(\"Query\")]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#flush\" } }, [_vm._v(\"Flush\")]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#info\" } }, [_vm._v(\"Info\")]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#setoption\" } }, [\n                      _vm._v(\"SetOption\"),\n                    ]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#initchain\" } }, [\n                      _vm._v(\"InitChain\"),\n                    ]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#beginblock\" } }, [\n                      _vm._v(\"BeginBlock\"),\n                    ]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#endblock\" } }, [\n                      _vm._v(\"EndBlock\"),\n                    ]),\n                  ]),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\n                  \"a\",\n                  {\n                    attrs: {\n                      href: \"#reconhecimento-de-entrega-de-pacotes-ibc\",\n                    },\n                  },\n                  [_vm._v(\"Reconhecimento de entrega de pacotes IBC\")]\n                ),\n              ]),\n              _c(\"li\", [\n                _c(\n                  \"a\",\n                  {\n                    attrs: { href: \"#arvore-merkle-e-especificacao-de-prova\" },\n                  },\n                  [_vm._v(\"Árvore Merkle e Especificação de Prova\")]\n                ),\n                _c(\"ul\", [\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#arvore-simples\" } }, [\n                      _vm._v(\"Árvore Simples\"),\n                    ]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#arvore-iavl\" } }, [\n                      _vm._v(\"Árvore IAVL+\"),\n                    ]),\n                  ]),\n                ]),\n              ]),\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#tipos-de-transacao\" } }, [\n                  _vm._v(\"Tipos de Transação\"),\n                ]),\n                _c(\"ul\", [\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#ibcblockcommittx\" } }, [\n                      _vm._v(\"IBCBlockCommitTx\"),\n                    ]),\n                  ]),\n                  _c(\"li\", [\n                    _c(\"a\", { attrs: { href: \"#ibcpackettx\" } }, [\n                      _vm._v(\"IBCPacketTx\"),\n                    ]),\n                  ]),\n                ]),\n              ]),\n            ]),\n          ]),\n          _c(\"li\", [\n            _c(\"a\", { attrs: { href: \"#agradecimentos\" } }, [\n              _vm._v(\"Agradecimentos\"),\n            ]),\n          ]),\n          _c(\"li\", [\n            _c(\"a\", { attrs: { href: \"#citacoes\" } }, [_vm._v(\"Citações\")]),\n            _c(\"ul\", [\n              _c(\"li\", [\n                _c(\"a\", { attrs: { href: \"#links-nao-classificados\" } }, [\n                  _vm._v(\"Links não classificados\"),\n                ]),\n              ]),\n            ]),\n          ]),\n        ]),\n      ]),\n      _c(\"p\"),\n      _c(\"p\", [\n        _vm._v(\n          \"O sucesso combinado do ecossistema de código aberto, compartilhamento\\nde arquivos descentralizado e criptomoedas públicas tem inspirado um conhecimento sobre\\nprotocolos descentralizados na Internet que podem ser utilizados para melhorar radicalmente\\na infraestrutura. Vimos aplicações de blockchain especializadas como Bitcoin\\n\"\n        ),\n        _c(\"a\", { attrs: { href: \"https://bitcoin.org/bitcoin.pdf\" } }, [\n          _vm._v(\"[1]\"),\n        ]),\n        _vm._v(\" (uma criptomoeda), Zerocash \"),\n        _c(\"a\", { attrs: { href: \"http://zerocash-project.org/paper\" } }, [\n          _vm._v(\"[2]\"),\n        ]),\n        _vm._v(\n          \" (uma criptomoeda para privacidade\\n), and generalized smart contract platforms such as Ethereum \"\n        ),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://github.com/ethereum/wiki/wiki/White-Paper\",\n            },\n          },\n          [_vm._v(\"[3]\")]\n        ),\n        _vm._v(\n          \",\\ncom inúmeras aplicações distribuídas para a Etherium Virtual Machine (EVM), como Augur (uma previsão\\nde mercado) e TheDAO \"\n        ),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://download.slock.it/public/DAO/WhitePaper.pdf\",\n            },\n          },\n          [_vm._v(\"[4]\")]\n        ),\n        _vm._v(\" (um clube de investimento).\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Contudo, até à data, estas blockchains sofreram uma série de inconvenientes,\\nincluindo sua ineficiência energética, desempenho fraco ou limitado e\\nmecanismos de governança imaturos. Propostas de escala\\nde processamento de transações da Bitcoin, como Testemunhas Separadas \"\n        ),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki\",\n            },\n          },\n          [_vm._v(\"[5]\")]\n        ),\n        _vm._v(\" e\\nBitcoinNG \"),\n        _c(\"a\", { attrs: { href: \"https://arxiv.org/pdf/1510.02037v2.pdf\" } }, [\n          _vm._v(\"[6]\"),\n        ]),\n        _vm._v(\n          \", soluções de escalonamento vertical que permanecem\\nlimitadas pela capacidade de uma única máquina física, a fim de\\nproporcionar uma auditabilidade completa. A Rede Lightning \"\n        ),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://lightning.network/lightning-network-paper-DRAFT-0.5.pdf\",\n            },\n          },\n          [_vm._v(\"[7]\")]\n        ),\n        _vm._v(\n          \" pode ajudar\\no Bitcoin no quesito volume de transações, deixando algumas transações completamente\\nfora da carteira, e é bem adequado para micropagamentos e preservando a privacisadade por pagamentos\\nRails, mas pode não ser adequado para necessidades de escala mais abrangente.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Uma solução ideal é a de permitir blockchains paralelos múltiplos para\\ninteroperação, mantendo suas propriedades de segurança. Isto provou\\nser difícil, se não impossível, com prova de trabalho. A mineração combinada, por exemplo,\\npermite que o trabalho feito para proteger uma blockchain mãe seja reutilizado em uma blockchain nova,\\nmas as transações ainda devem ser validadas, em ordem, por cada nó, e uma\\nblockchain Merge-mined é vulnerável a ataques se a maioria do poder de\\nhashing sobre a mãe não é ativamente merge-mined da nova. Uma revisão acadêmica\\ndo \"\n        ),\n        _c(\"a\", { attrs: { href: \"http://vukolic.com/iNetSec_2015.pdf\" } }, [\n          _vm._v(\"arquiteturas de redes alternativas blockchain\\n\"),\n        ]),\n        _vm._v(\n          \" é fornecida para\\ncontextualizar, e fornecemos resumos de outras propostas e suas desvantagens em\\n\"\n        ),\n        _c(\"a\", { attrs: { href: \"#trabalho-relatado\" } }, [\n          _vm._v(\"Trabalho relatado\"),\n        ]),\n        _vm._v(\".\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Nesse relato nós apresentamos a Cosmos, uma novela da arquitetura de rede blockchain que aborda todos\\nesses problemas. Cosmos é uma rede de muitos blockchains independentes, chamados\\nZonas. As zonas são alimentadas pelo Tendermint BFTork \"\n        ),\n        _c(\n          \"a\",\n          { attrs: { href: \"https://github.com/tendermint/tendermint/wiki\" } },\n          [_vm._v(\"[8]\")]\n        ),\n        _vm._v(\", que fornece uma\\nalta performace, consistência, segurança\\n\"),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://blog.cosmos.network/tendermint-vs-pbft-12e9f294c9ab\",\n            },\n          },\n          [_vm._v(\"PBFT-como\")]\n        ),\n        _vm._v(\" um mecanismo de consenso\\nrigoroso, onde \"),\n        _c(\"a\", { attrs: { href: \"#fork-respons%C3%A1vel\" } }, [\n          _vm._v(\"fork-responsável\"),\n        ]),\n        _vm._v(\n          \" tem-se garantias de deter\\ncomportamentos maliciosos. O algoritmo de consenso BFT do Tendermint BFT é\\nbem adaptado para integrar blockchains públicas de prova de estaca.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"A primeira zona na Cosmos é chamada de Cosmos Hub. A Cosmos Hub é uma criptomoeda\\nmulti-asset de prova de estaca com um simples mecanismo de governança\\no qual permite a rede se adaptar e atualizar. Além disso, a Cosmos Hub pode ser\\nextendida por conexão com outras zonas.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"O hub e as zonas da rede Cosmos comunicam-se uma com a outra através de um\\nprotocolo de comunicação Inter-blockchain (IBC), um tipo de UDP ou TCP virtual para\\nblockchains. Os tokens podem ser transferidos de uma zona para outra com segurança e\\nrapidez sem necessidade de liquidez cambial entre as zonas. Em vez disso, todas\\nas transferências de tokens inter-zonas passam pelo Hub Cosmos, que mantêm\\na quantidade total de tokens detidas por cada zona. O hub isola cada zona da\\nfalha das outras zonas. Porque qualquer um pode conectar uma nova zona no Hub Cosmos,\\no que permite futuras compatibilidades com novas blockchains inovadoras.\"\n        ),\n      ]),\n      _c(\"h2\", { attrs: { id: \"tendermint\" } }, [_vm._v(\"Tendermint\")]),\n      _c(\"p\", [\n        _vm._v(\n          \"Nesta seção, descrevemos o protocolo de consenso da Tendermint e a interface\\nusada para construir aplicações através dele. Para mais detalhes, consulte o \"\n        ),\n        _c(\"a\", { attrs: { href: \"#ap%C3%AAndice\" } }, [_vm._v(\"apêndice\")]),\n        _vm._v(\".\"),\n      ]),\n      _c(\"h3\", { attrs: { id: \"validadores\" } }, [_vm._v(\"Validadores\")]),\n      _c(\"p\", [\n        _vm._v(\n          \"No algorítimo de tolerância e falhas clássicas Bizantinas (BFT), cada node tem o mesmo\\npeso. Na Tendermint, nodes tem uma quantidade positiva de \"\n        ),\n        _c(\"em\", [_vm._v(\"poder de voto\")]),\n        _vm._v(\n          \", e\\nesses nodes que tem poder de voto positivo são chamados de \"\n        ),\n        _c(\"em\", [_vm._v(\"validadores\")]),\n        _vm._v(\n          \". Validadores\\nparticipam de um protocolo de consenso por transmissão de assinaturas criptográficas,\\nou \"\n        ),\n        _c(\"em\", [_vm._v(\"votos\")]),\n        _vm._v(\", para concordar com o próximo bloco.\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Os poderes de voto dos validadores são determinados na gênese, ou são alterados\\nde acordo com a blockchain, dependendo da aplicação. Por exemplo,\\nem uma aplicação de prova de participação, como o Hub da Cosmos, o poder de voto pode ser\\ndeterminado pela quantidade de tokens usados como garantia.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _c(\"em\", [\n          _vm._v(\n            \"NOTA: Frações como ⅔ e ⅓ referem-se a frações do total de votos,\\nnunca o número total de validadores, a menos que todos os validadores tenham\\npeso.\"\n          ),\n        ]),\n        _c(\"em\", [\n          _vm._v(\n            \"NOTE: +⅔ significa “mais do que ⅔”, enquanto ⅓+ significa “⅓ ou mais”.\"\n          ),\n        ]),\n      ]),\n      _c(\"h3\", { attrs: { id: \"consenso\" } }, [_vm._v(\"Consenso\")]),\n      _c(\"p\", [\n        _vm._v(\n          \"Tendermint é um protocolo de consenso BFT parcialmente sincronizado e derivado do\\nalgoritmo de consenso DLS \"\n        ),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf\",\n            },\n          },\n          [_vm._v(\"[20]\")]\n        ),\n        _vm._v(\". Tendermint é notável por sua simplicidade,\\ndesempenho, e \"),\n        _c(\"a\", { attrs: { href: \"#fork-respons%C3%A1vel\" } }, [\n          _vm._v(\"fork-responsável\"),\n        ]),\n        _vm._v(\n          \". O protocolo\\nrequer um grupo determinado de validadores, onde cada validador é identificado por\\nsua chave pública. Validadores chegarão a um consenso em um bloco por vez,\\nonde um bloco é uma lista de transações. A votação para o consenso sobre um bloco\\nacontece por rodada. Cada rodada tem uma líder-de-rodada, ou proponente, que propõe um bloco. Os\\nvalidadores, em seguida, votam, por etapas, sobre a aceitação do bloco proposto\\nou passam para a próxima rodada. O proponente de uma rodada é escolhido\\nde acordo com uma lista ordenada de validadores, proporcionalmente à seu\\npoder de voto.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Os detalhes completos do protocolo estão descritos\\n\"),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://github.com/tendermint/tendermint/wiki/Byzantine-Consensus-Algorithm\",\n            },\n          },\n          [_vm._v(\"aqui\")]\n        ),\n        _vm._v(\".\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"A segurança da Tendermint é baseada na tolerância e falhas clássicas Bizantinas ótimas\\natravés de super-maioria (+⅔) e um mecanismo de bloqueio. Juntas, elas garantem\\nisso:\"\n        ),\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\n            \"⅓+ o poder de voto deve ser bizantino devido a violações de segurança, onde mais\\n  que dois valores são comprometidos.\"\n          ),\n        ]),\n        _c(\"li\", [\n          _vm._v(\n            \"se algum conjunto de validadores tiver sucesso em violar a segurança, ou mesmo tentarem\\npara isso, eles podem ser identificados pelo protocolo. Isso inclui tanto o voto\\npara blocos conflitantes quanto a transmissão de votos injustificados.\"\n          ),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Apesar de suas fortes garantias, a Tendermint oferece um desempenho excepcional. Dentro\\nde Benchmarks de 64 nós distribuídos em 7 datacenters em 5 continentes, em\\nnuvens de commodities, o consenso da Tendermint pode processar milhares de\\ntransações por segundo, com tempo de resposta entre um a dois\\nsegundos. Notavelmente, o desempenho muito além de mil transações por segundo\\né mantido mesmo em condições adversas, com validadores falhando ou\\ncombinando votos maliciosamente. Veja a figura abaixo para mais detalhes.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _c(\"img\", {\n          attrs: {\n            src: \"https://raw.githubusercontent.com/gnuclear/atom-whitepaper/master/images/tendermint_throughput_blocksize.png\",\n            alt: \"Figura do desempenho da Tendermint\",\n          },\n        }),\n      ]),\n      _c(\"h3\", { attrs: { id: \"clientes-light\" } }, [_vm._v(\"Clientes Light\")]),\n      _c(\"p\", [\n        _vm._v(\n          \"O principal benefício do algoritmo de consenso da Tendermint é um cliente leve e simplificado\\nde segurança, tornando-o um candidato ideal para o uso de dispositivos móveis e casos de uso na\\ninternet. Enquanto um cliente leve do Bitcoin deve sincronizar blockchains e encontrar\\no que tem mais prova de trabalho, os clientes light da Tendermint precisa apenas\\ndas alterações feitas pelo conjunto dos validadores, em seguida, verifica-se o +⅔ PreCommits\\nno último bloco para determinar o estado atual.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Provas claras e sucintas do cliente também permite \"),\n        _c(\n          \"a\",\n          { attrs: { href: \"#comunica%C3%A7%C3%A3o-inter-blockchain-ibc\" } },\n          [_vm._v(\"comunicação-inter-\\nblockchain\")]\n        ),\n        _vm._v(\".\"),\n      ]),\n      _c(\"h3\", { attrs: { id: \"previnindo-ataques\" } }, [\n        _vm._v(\"Previnindo ataques\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"A Tendermint dispõe de medidas de proteção para evitar\\nataques, como \"\n        ),\n        _c(\n          \"a\",\n          { attrs: { href: \"#previnindo-ataques-de-longa-dist%C3%A2ncia\" } },\n          [_vm._v(\"gastos duplos em longa-distância-sem-estaca double\\nspends\")]\n        ),\n        _vm._v(\" e\\n\"),\n        _c(\"a\", { attrs: { href: \"#superando-forks-e-censurando-ataques\" } }, [\n          _vm._v(\"censura\"),\n        ]),\n        _vm._v(\". Esses são discutidos\\ncompletamente no \"),\n        _c(\"a\", { attrs: { href: \"#ap%C3%AAndice\" } }, [_vm._v(\"apêndice\")]),\n        _vm._v(\".\"),\n      ]),\n      _c(\"h3\", { attrs: { id: \"tmsp\" } }, [_vm._v(\"TMSP\")]),\n      _c(\"p\", [\n        _vm._v(\n          \"O algoritmo de consenso Tendermint é implementado através de um programa chamado Tendermint\\nCore. O Tendermint BFT é um “mecanismo de consenso” independente de aplicações que\\ntransformam qualquer aplicação blackbox em uma réplica distribuída na\\nBlockchain. Tendermint BFT conecta-se ao blockchain\\natravés de aplicações do Tendermint Socket Protocol (TMSP) \"\n        ),\n        _c(\"a\", { attrs: { href: \"https://github.com/tendermint/tmsp\" } }, [\n          _vm._v(\"[17]\"),\n        ]),\n        _vm._v(\n          \". Assim, o TMSP\\npermite que as aplicações da blockchain sejam programadas em qualquer idioma, não apenas\\na linguagem de programação que o mecanismo de consenso é escrito, além disso,\\no TMSP torna possível a troca fácil da camada de consenso de qualquer\\ntipo de blockchain.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Nós fizemos uma analogia com a bem conhecida criptogradia do Bitcoin. Bitcoin é uma\\nblockchain de criptomoedas onde cada nó mantém uma Unspent totalmente auditada\\ne banco de dados de saída de transação (UTXO). Se alguém quisesse criar um Bitcoin-like\\nTMS, a Tendermint BFT seria responsável por\"\n        ),\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [_vm._v(\"Compartilhar blocos e transações entre os nós\")]),\n        _c(\"li\", [\n          _vm._v(\n            \"Estabelecer uma ordem de transações canônica/imutável (a blockchain)\"\n          ),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"Entretanto, o aplicativo TMSP seria responsável por\")]),\n      _c(\"ul\", [\n        _c(\"li\", [_vm._v(\"Manter o banco de dados UTXO\")]),\n        _c(\"li\", [\n          _vm._v(\"Validar a criptografia das assinaturas das transações\"),\n        ]),\n        _c(\"li\", [\n          _vm._v(\n            \"Previnir transações vindas de gastos de fundos não exisentes\"\n          ),\n        ]),\n        _c(\"li\", [\n          _vm._v(\"Permitir aos clientes a consulta do banco de dados UTXO\"),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Tendermint é capaz de decompor o design da blockchain, oferecendo um simples\\nAPI entre o processo da aplicação e o processo do consenso.\"\n        ),\n      ]),\n      _c(\"h2\", { attrs: { id: \"visao-geral-da-cosmos\" } }, [\n        _vm._v(\"Visão Geral da Cosmos\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Cosmos é uma rede de blockchains paralelos e independentes que são alimentadas pelo\\nclássico algorítimo de consenso BFT como a Tendermint\\n\"\n        ),\n        _c(\n          \"a\",\n          { attrs: { href: \"http://github.com/tendermint/tendermint\" } },\n          [_vm._v(\"1\")]\n        ),\n        _vm._v(\".\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"A primeira blockchain dessa rede será a Cosmos Hub. A Cosmos Hub\\nconecta as outras blockchains (ou \"\n        ),\n        _c(\"em\", [_vm._v(\"zonas\")]),\n        _vm._v(\n          \") através do protocolo de comunicação-inter-\\nblockchain. A Cosmos Hub rastreia vários tipos de tokens e mantém\\nregisto do número total de tokens em cada zona ligada. Os tokens podem ser\\ntransferidos de uma zona para outra de forma segura e rápida, sem necessidade de\\numa troca líquida entre zonas, porque todas as transferências de moedas ocorre\\natravés da Cosmos Hub.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Essa arquitetura resolve muitos dos problemas enfrentados atualmente pelas blockchains,\\ntais como interoperabilidade de aplicativos, escalabilidade e capacidade de atualização contínua.\\nPor exemplo, as zonas baseadas do Bitcoin, Go-Ethereum, CryptoNote, ZCash, ou qualquer\\nsistema blockchain pode ser ligado ao Cosmos Hub. Essas zonas permite a Cosmos\\no escalonamento infinito para atender a demanda global de transações. As Zonas também são um grande\\napoio para a exchange distribuída, que também serão apoiadas.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Cosmos não é apenas uma única ledger distribuídos, o Cosmos Hub não é um\\njardim cercado ou o centro do universo. Estamos elaborando um protocolo para\\numa rede aberta de legers distribuídos que pode servir como um novo\\nfuturos para sistemas financeiros, baseados em princípios de criptografia, economia\\nteoria de consenso, transparência e responsabilidade.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"tendermint-bft\" } }, [_vm._v(\"Tendermint-BFT\")]),\n      _c(\"p\", [\n        _vm._v(\n          \"O Cosmos Hub é a primeira blockchain pública na rede Cosmos, alimentada pelo\\nalgoritimo de consenso BFT Tendermint. A Tendermint é um projeto de fonte aberta que\\nnasceu em 2014 para abordar a velocidade, a escalabilidade e as questões\\ndo algoritimo de consenso da prova-de-trabalho do Bitcoin. Usando e melhorando\\nalgoritmos BFT comprovados e desenvolvidos no MIT em 1988 \"\n        ),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf\",\n            },\n          },\n          [_vm._v(\"[20]\")]\n        ),\n        _vm._v(\n          \", o time Tendermint foi o primeiro a\\nque demonstrou conceitualmente uma prova de estaca das criptomoedas que aborda o\\nproblema de “sem-estaca” sofrido pelas criptomoedas da primeira geração\\ntais como NXT e BitShares.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Hoje, praticamente todas carteiras móveis de Bitcoin usam servidores confiáveis, que fornece\\na elas transações com verificação. Isso porque a prova-de-trabalho exige\\nmuitas confirmações antes que uma transação possa ser considerada\\nirreversivel e completa. Os ataques de gasto-duplo já foram demonstrados em\\nserviços como a CoinBase.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Ao contrário de outros sistemas de consenso blockchain, a Tendermint oferece\\ncomprovação segura de pagamento para o cliente móvel. Uma vez que a Mint é\\nprojetada para nunca passar por um fork, carteiras móveis podem receber confirmações de transações\\ninstantâneas, o que torna os pagamentos confiáveis e práticos através de\\nsmartphones. Isto tem implicações significativas para as aplicações da Internet.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Validadores na Cosmos tem uma função similar aos mineiros do Bitcoin, mas usam\\nassinaturas criptografadas para votar. Validadores são máquinas seguras e dedicadas\\nque são responsáveis por validar os blocos. Os não validadores podem delegar através de seus tokens estacados\\n(chamados “atoms”) a qualquer validador para ganhar uma parcela das taxas da blockchain\\ne recompensas de atoms, mas eles correm o risco de serem punidos (cortados) se o\\no validador de delegados for invadido ou violar o protocolo. A segurança comprovada\\ngarantida pelo consenso BFT da Tendermint, e o depósito de garantia das\\npartes interessadas - validadores e delegados - fornecem dados prováveis,\\nsegurança para os nós e clientes light.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"governanca\" } }, [_vm._v(\"Governança\")]),\n      _c(\"p\", [\n        _vm._v(\n          \"Ledgers de distribuição pública devem ser constituídos de um sistema de governança.\\nO Bitcoin confia na Fundação Bitcoin e na mineração para\\ncoordenar upgrades, mas este é um processo lento. Ethereum foi dividido em ETH e\\nETC depois de hard-fork para se recuperar do hack TheDAO, em grande parte porque não havia\\ncontrato sócial prévio, nem um mecanismo para tomar tais decisões.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Os validadores e os delegados do Cosmos Hub podem votar propostas que\\nalteraram automaticamente os parâmetros predefinidos do sistema (tal como o gás limite do\\nbloco), coordenar upgrades, bem como votar em emendas para a\\nconstituição que governa as políticas do Cosmos Hub. A Constituição\\npermite a coesão entre as partes interessadas em questões como o roubo\\ne bugs (como o incidente TheDAO), permitindo uma resolução mais rápida e mais limpa.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Cada zona pode ter sua própria constituição e mecanismo de governança.\\nPor exemplo, o Cosmos Hub pode ter uma constituição que reforça a imutabilidade\\nno Hub (sem roll-backs, a não ser por bugs em implementações dos nós do Cosmos Hub),\\nenquanto cada zona pode ter sua própria política sobre os roll-backs.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Ao disponibilizar a interoperabilidade em diferentes políticas das zonas, a rede Cosmos\\ndá aos usuários total liberdade e potenciais permissões para\\nexperimentos.\"\n        ),\n      ]),\n      _c(\"h2\", { attrs: { id: \"o-hub-e-as-zonas\" } }, [\n        _vm._v(\"O Hub e as Zonas\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          'Aqui nós descrevemos o modelo do roteiro de descentralização e ecalabilidade. Cosmos é uma\\nrede de muitas blockchains alimentadas pela Tendermint. Enquanto existirem propostas visando\\ncriar um\"blockchain solitário\" com ordens de transações cheias, a Cosmos\\npermite que muitas blockchains rodem junto de outra enquanto mantêm a\\ninteroperabilidade.'\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Basicamente, o Cosmos Hub gerencia várias blockchains independentes chamadas “zonas”\\n(as vezes chamadas de “shards”, em referência a técnica de escalonamento de\\nbando de dados conhecida como “sharding”). Uma constante transmissão de blocos recentes das\\nzonas atuando no Hub permite ao Hub manter o estado de cada zona atualizado.\\nSendo assim, cada zona mantêm ativa o estado do Hub (mas as zonas não se mantêm ativas\\ncom qualquer outro exceto o Hub). Pacotes de informação são\\nentão comunicados de uma zona para outra atráves de Merkle-proofs como evidências,\\nessas informações são enviadas e recebidas. Esse mecanismo é chamado de\\ncomunicação inter-blockchain, ou IBC para encurtar.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _c(\"img\", {\n          attrs: {\n            src: \"https://raw.githubusercontent.com/gnuclear/atom-whitepaper/master/images/hub_and_zones.png\",\n            alt: \"Figura de reconhecimentodo hub e das zonas\",\n          },\n        }),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Qualquer uma das zonas podem ser hubs para formar gráficos acíclicos, mas\\nmas para deixar claro, nós vamos apenas descrever uma simples configuração para\\num único hub, e várias zonas que não são hubs.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"o-hub\" } }, [_vm._v(\"O Hub\")]),\n      _c(\"p\", [\n        _vm._v(\n          \"O Cosmos Hub é uma blockchain que hospeda um ledger de distribuíção de multi-asset,\\nonde os tokens podem ser mantidos por usuários individuais ou pelas próprias zonas. Esses\\ntokens podem ser movidos de uma zona para outra em um pacote IBC especial chamado\\n“coin packet”. O hub é responsavel por preservar a manutenção global de\\ntoda a quantia de cada token nas zonas. As transações de moedas no pacote IBC\\nprecisam ser feitas pelo remetente, hub, e blockchain recebedor.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Desde a atuação do Cosmos Hub como ledger principal para todos o\\nsistema, a segurança do Hub é de suma importância. Enquanto cada\\nzona pode ser uma blockchain Tendermint que é segurada por 4((ou talvez\\nmenos caso o consenso BFT não seja necessário), o Hub precisa ser segurado por uma descentralização\\nglobalizada feita pelos validadores que podem evitar os mais severos tipos de\\nataques, como uma partição de rede continental ou um estado-nação fazendo\\nataques.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"as-zonas\" } }, [_vm._v(\"As Zonas\")]),\n      _c(\"p\", [\n        _vm._v(\n          \"Uma zona Cosmos é uma blockchain independente das trocas de mensagens IBC com o\\nHub. Na perspectiva do Hub, uma zona é uma conta multi-asset dynamic-membership\\nmulti-signature que pode enviar e receber tokens usando pacotes IBC. Como\\numa conta de criptomoeda, uma zona não pode transferir mais tokens do que ela possui, mas\\npode receber tokens de outras que os tem. Uma zona pode ser usada como uma\\n“fonte” de um ou mais tipos de tokens, garantindo o poder de aumentar o estoque desse\\ntoken.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Os atoms do Cosmos Hub podem ser estacados por validadores de uma zona conectada ao\\nHub. Enquanto os ataques de gasto-duplo nesses zonas podem resultar em um core dos\\natoms com o fork-responsável da Tendermint, uma zona onde +⅔ do poder de voto\\nsão Bizantinos podem deixar o estado inválido. O Cosmos Hub não verifica ou\\nexecuta transações ocorridas em outras zonas, então essa é uma responsabilidade dos\\nusuários para enviar os tokes ara zonas que eles confiem. Futuramente, o sistema de\\ngovernança do Cosmos Hub irá implementar propostas para o Hub e para as falhas\\ndas zonas. Por exemplo, um token de saída transferido para algumas (ou todas) zonas podem ser\\nsegurados em caso de uma emergência de quebra de circuito das zonas(uma parada temporária\\nnas transferências dos tokens) quando um ataque é detectado.\"\n        ),\n      ]),\n      _c(\"h2\", { attrs: { id: \"comunicacao-inter-blockchain-ibc\" } }, [\n        _vm._v(\"Comunicação Inter-blockchain (IBC)\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Agora nós olhamos para como o Hub e as zonas vão se comunicar. Por exemplo, se\\naqui são três blockchains, “Zona1”, “Zona2”, and “Hub”, e nós queremos que a\\n“Zona1” produza um pacote destinado para a “Zona2” indo através do “Hub”. Para mover um\\npacote de uma blockchain para outra, uma prova é feita na\\ncadeia recebedora. A prova atesta esse envio publicado na cadeia de destino por uma alegação\\nde pacote. Para a cadeia recebedora checar essa prova, isso é possível\\npor um block principal de envio. Esse mecanismo é similar ao usado por\\ncadeias paralelas, que requerem duas cadeias interagindo uma com a outra via\\ntransmissões bidirecionais por dados de prova-de-existência (transações).\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"O protocolo IBC pode naturalmente ser definido usando dois tipos de transações: uma\\ntransação \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCBlockCommitTx\")]),\n        _vm._v(\n          \", a qual permite uma blockchain provar para qualquer\\nespectador o mais recente hash-de-bloco, e uma transação \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketTx\")]),\n        _vm._v(\n          \", a qual\\npermite uma blockchain provar para qualquer espectador que o pacote recebido foi realmente\\npublicado pelo remetente, via Merkle-proof para um hash-de-bloco\\nrecente.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Ao misturar o mecanismo ICB em duas transações separadas, nós permitimos\\nque o mecanismo de mercado de taxa nativa da blockchain recebedora determine quais pacotes\\nirão se comprometer (isto é, ser reconhecido), permitindo simultaneamente que uma\\nblockchain envie de quantos pacotes de saída forem permitidos.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _c(\"img\", {\n          attrs: {\n            src: \"https://raw.githubusercontent.com/gnuclear/atom-whitepaper/master/msc/ibc_without_ack.png\",\n            alt: \"Figura da Zona1, Zona2, e Hub IBC semreconhecimento\",\n          },\n        }),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"No exemplo acima, para atualizar o hash de blocos da\\n“Zona1” no “Hub” (ou do “Hub” para a “Zona2”), uma transação \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCBlockCommitTx\")]),\n        _vm._v(\n          \"\\nprecisa ser feita no “Hub” com o hash de bloco da “Zona1” (ou na\\n“Zona2” com o hash de bloco do “Hub”).\"\n        ),\n      ]),\n      _c(\"p\", [\n        _c(\"em\", [\n          _vm._v(\"Veja \"),\n          _c(\"a\", { attrs: { href: \"#ibcblockcommittx\" } }, [\n            _vm._v(\"IBCBlockCommitTx\"),\n          ]),\n          _vm._v(\" e \"),\n          _c(\"a\", { attrs: { href: \"#ibcpacketcommit\" } }, [\n            _vm._v(\"IBCPacketTx\"),\n          ]),\n          _vm._v(\"\\npara mais informações sobre os 2 tipos de transação IBC.\"),\n        ]),\n      ]),\n      _c(\"h2\", { attrs: { id: \"casos-de-uso\" } }, [_vm._v(\"Casos de Uso\")]),\n      _c(\"h3\", { attrs: { id: \"exchange-distribuidas\" } }, [\n        _vm._v(\"Exchange Distribuídas\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Da mesma forma que Bitcoin é mais seguro por ter uma distribuíção,\\ne replicação em massa, podemos tornar as exchanges menos vulneráveis a\\nHacks internos executando-a no blockchain. Chamamos isso de exchange\\ndistribuída.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"O que a comunidade de criptomoedas chama hoje de intercâmbio descentralizado\\nbaseado em algo chamado transações “atomic cross-chain” (AXC). Com uma transação\\nAXC, dois usuários em duas diferentes cadeias podem fazer duas transações\\nde transferências que serão feitas juntas nas duas ledgers, ou nenhuma (isto é,\\nAtomicamente). Por exemplo, dois usuários podem trocar bitcoins por ether (ou qualquer dois\\nTokens em dois ledgers diferentes) usando transações AXC, mesmo que o Bitcoin\\ne o Ethereum não estão conectados entre si. O benefício de executar um\\ntroca em transações AXC é que nenhum dos usuários precisam confiar um no outro ou\\nno serviço de correspondência comercial. A desvantagem é que ambas as partes precisam estar\\non-line para o negócio ocorrer.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Outro tipo de intercâmbio descentralizado é um sistema de\\nexchange que funciona em seu próprio blockchain. Os usuários deste tipo de exchange podem\\nenviar uma ordem de limite e desligar o computador, e o negócio pode ser executado\\nsem que o usuário esteja online. O blockchain combina e completa o negócio\\nem nome do negociante.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Uma exchange centralizada pode criar um vasto livro de ordens de ordens e\\natrair mais comerciantes. A liquidez gera mais liquidez no mundo cambial,\\ne assim há um forte efeito na rede (ou pelo menos efeito de vencedor-leva-mais)\\nno negócio de câmbio. A atual líder para troca de criptomoedas\\nhoje é a Poloniex com um volume de 24 milhões de dólares por dia, e em segundo lugar a\\nBitfinex com um volume de US$5 milhões por dia. Dados esses fortes efeitos na rede,\\né improvável que as exchanges descentralizadas baseadas no AXC ganhem volume\\ncentrais. Para uma exchange descentralizada competir com um\\nexchange centralizada, seria necessário dar suporte aos livros de\\nordens. Somente uma exchange distribuída em uma blockchain pode fornecer isso.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Tendermint fornece benefícios adicionais para realizar uma transação mais rápida. Com a\\nfinalidade de dar prioridade a rapidez sem sacrificar a consistência, as zonas no Cosmos podem\\nfinalizar transações rápidas - tanto para transações de ordem de\\ntransferências de tokens quanto para outras zonas IBC.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Dado o estado das exchanges de criptomoedas hoje em dia, uma grande\\nexchange distribuída da Cosmos (aka o Cosmos DEX). A transação e\\na capacidade de processamento, bem como a latência de processos, podem ser\\ncentrais. Os comerciantes podem enviar ordens de limite que podem ser executadas\\nsem que ambas as partes tenham que estar online. E com Tendermint, o Cosmos Hub,\\ne o IBC, os comerciantes podem mover fundos dentro e fora da exchange e para outras\\nzonas com rapidez.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"pegging-para-outras-criptomoedas\" } }, [\n        _vm._v(\"Pegging para Outras Criptomoedas\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Uma zona privilegiada pode agir como token simbolico de uma\\ncriptomoeda. A peg é semelhante à relação entre uma\\nzona e o Cosmos Hub; Ambos devem manter-se atualizados com os\\noutros, afim de verificar provas de que os tokens passaram de um para o outro. A\\nPeg-zone na rede Cosmos mantém-se com o Hub, bem como o\\noutra cryptomoeda. A indireção através da peg-zone permite a lógica de\\nque o Hub permaceça simples e imutável para outras estratégias de consenso blockchain\\ncomo a mineração de prova-de-trabalho do Bitcoin.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Por exemplo, uma zona Cosmos com um conjunto validador específico, possivelmente o mesmo que\\no Hub, poderia atuar como um ether-peg, onde a aplicação TMSP sobre\\na zona (“peg-zone”) tem mecanismos para trocar mensagens IBC com um\\nPeg-contract na blockchain (a “origem”). Este contrato\\npermite que os titulares de ether enviem ether para a zona de peg, enviando-o para\\nPeg-contract na Ethereum. Uma vez que o ether é recebido pelo peg-contract, o ether\\nnão pode ser retirado a menos que um pacote IBC apropriado seja recebido pelo\\nPeg-contract da peg-zone. Quando uma zona recebe um pacote IBC provando\\nque o ether foi recebido no peg-contract para uma determinada conta Ethereum,\\na conta correspondente é criada na peg-zone com esse saldo. O ether na\\npeg-zone (“pegged-ether”) pode então ser transferido para o Hub,\\ne mais tarde ser destruído com uma transação que envia para um determinado\\nendereço de retirada no Ethereum. Um pacote IBC provando que a transação\\nna Peg-Zone podem ser lançados no peg-contract Ethereum para permitir que o\\nEther seja retirado.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Naturalmente, o risco do contrato do pegging e um conjunto de validadores desonestos. -bizantino.\\nO poder de voto bizantino poderia causar um fork, retirando o ether do\\npeg-contract mantendo o pegged-ether na peg-zone. Na pior das hipóteses,\\n+⅔ do poder de voto bizantino pode roubar o ether daqueles que o enviaram para o\\npeg-contract, desviando-se da pegging e da peg-zone de origem.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"É possível abordar essas questões projetando o peg para ser totalmente\\nresponsável. Por exemplo, todos os pacotes IBC, a partir do hub de\\norigem, poderão exigir um reconhecimento pela zona de fixação de tal forma que\\nas transições de estados da peg-zone podem ser desafiadas de forma eficiente e verificadas pelo\\nhub ou pelo peg-contract de origem. O Hub e a origem devem\\npermitir que os validadores da zona de fixação apresentem garantias e as transferências\\ncontratuais devem ser atrasadas (e um prazo de vinculação de colateral suficientemente\\nlongo) para permitir que quaisquer desafios sejam feitos por auditores independentes. Nós saímos\\nda concepção, da especificação e implementação deste sistema aberto como uma\\nfutura proposta de melhoria da Cosmos, a ser aprovada pela governança do sistema do Cosmos\\nHub.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Embora a atmosfera sociopolítica ainda não esteja bastante desenvolvida, podemos\\naumentar o mecanismo para permitir que as zonas se liguem as moedas FIAT de um\\nestado-nação, formando um validador responsável estabelecido a partir de uma combinação da\\nmoeda da nação, mais particularmente, pelos seus bancos. Claro,\\nprecauções adicionais devem ser tomadas para aceitar apenas moedas apoiadas por\\nsistemas que possam reforçar a capacidade de auditoria das atividades dos bancos\\ne de notário grupos de grandes instituições de confiança.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Um resultado dessa integração poderia ser, por exemplo, permitir que\\numa conta em um banco na zona possa mover dólares de sua conta bancária\\npara outras contas na zona, ou para o hub, ou inteiramente para outra zona.\\nNesse sentido, o Cosmos Hub pode atuar como um canal sem\\nmoedas e criptomoedas, removendo as barreiras que limitariam\\nsua interoperabilidade com o mundo dos intercâmbios.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"ethereum-scaling\" } }, [\n        _vm._v(\"Ethereum Scaling\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Resolver o problema de escalonamento é um problema aberto para a Ethereum. Atualmente,\\nos nós Ethereum processam cada transação única e também armazenam todos os estados.\\n\"\n        ),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://docs.google.com/presentation/d/1CjD0W4l4-CwHKUvfF5Vlps76fKLEC6pIwu1a_kC_YRQ/mobilepresent?slide=id.gd284b9333_0_28\",\n            },\n          },\n          [_vm._v(\"link\")]\n        ),\n        _vm._v(\".\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Desde que a Tendermint pode realizar os blocos muito mais rápido do que a prova-de-trabalho da Ethereum,\\nas zonas EVM alimentadas e operando pelo consenso da Tendermint\\nfornecem maior desempenho para blocos da blockchain Ethereum. Além disso, embora o\\nCosmos Hub e o mecanismo de pacotes IBC não permitam a execução da lógica de contratos\\narbitrários, podem ser usados para coordenar os movimentos Ethereum e a execução de\\ncontratos simbólicos em diferentes zonas, fornecendo uma base para\\no token ethereum através de sharding.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"integracao-de-multi-aplicacao\" } }, [\n        _vm._v(\"Integração de Multi-Aplicação\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"As zonas Cosmos executam lógica de aplicação arbitrária, que é definida no início da\\nvida da zona e podem potencialmente ser atualizados ao longo do tempo pela governança. Essa flexibilidade\\npermite que as zonas Cosmos ajam como pegs para outras criptomoedas como Ethereum ou\\nBitcoin, e também permite derivados desses blockchains, que utilizam a\\nmesma base de código, mas com um conjunto de validador diferente e distribuição inicial. Isto\\npermite que muitos tipos de criptomoedas existentes, como as Ethereum,\\nZerocash, Bitcoin, CryptoNote e assim por diante, possam ser usados com o Tendermint BFT,\\nque é um motor de consenso de maior desempenho, em uma rede comum, abrindo\\noportunidade de interoperabilidade entre as plataformas. Além disso, como\\nmulti-asset blockchain, uma única transação pode conter vários\\nonde cada entrada pode ser qualquer tipo de token, permitindo a Cosmos\\nser uma plataforma para a exchange descentralizada, mesmo que as ordens sejam\\npara outras plataformas. Alternativamente, uma zona pode servir como um\\nfault-tolerant (com livros de ordens), o que pode ser uma melhoria\\nnas exchanges centralizadas de criptomoeda que tendem a ser invadidas com\\no tempo.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"As zonas também podem servir como versões bloqueadas de empresas e\\nsistemas, onde partes de um serviço particular da organização ou grupo de organizações\\nque são tradicionalmente executadas como um aplicativo TMSP\\nem uma certa zona, o que lhe permite receber a segurança e a interoperabilidade da\\nrede pública Cosmos sem sacrificar o controle sobre o serviço subjacente.\\nAssim, a Cosmos pode oferecer o melhor da tecnologia blockchain para ambos os mundos e\\npara as organizações, que se recusam a deixar completamente o controle\\npara um distribuidor terceirizado.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"reducao-de-particao-de-rede\" } }, [\n        _vm._v(\"Redução de partição de rede\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Alguns afirmam que um grande problema da coerência-favorecendo algoritmos de consenso\\ncomo o Tendermint é que qualquer partição de rede que faz com que não haja uma única\\npartição com +⅔ de poder de votação (por exemplo, ⅓+ ficando offline) irá parar o consenso\\ncompletamente. A arquitetura Cosmos pode ajudar a mitigar esse problema usando umas\\nzonas regionais autônomas, onde o poder de voto para cada zona é\\ndistribuído com base em uma região geográfica comum. Por exemplo, um\\nparâmetro pode ser para cidades individuais, ou regiões, para operar suas próprias zonas\\nde partilha com um centro em comum (por exemplo, o Cosmos Hub), permitindo que a\\no hub possa parar devido a uma paralisação de rede temporária.\\nObserve que isso permite uma geologia real, política e rede-topológica,\\nque são recursos a serem considerados no projeto de sistemas robustos federados de fault-tolerant.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"sistema-de-resolucao-de-nomes-federados\" } }, [\n        _vm._v(\"Sistema de Resolução de Nomes Federados\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"NameCoin foi uma das primeiras blockchains a tentar resolver o\\nproblema de resolução de nomes através de uma adaptação da blockchain do Bitcoin. Infelizmente\\ntêm ocorrido várias questões com esta abordagem.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Com a Namecoin, podemos verificar que, por exemplo, o nome \"),\n        _c(\"em\", [_vm._v(\"@satoshi\")]),\n        _vm._v(\n          \" foi registrado como\\nparticular, em algum momento do passado, mas não saberíamos se\\na chave pública tinha sido atualizada recentemente, a menos que baixassemos todos os blocos\\ndesde a última atualização desse nome. Isto é devido as limitações do modelo de\\nMerkle-ization de UTXO do Bitcoin, onde somente as transações (não\\nmutáveis) são Merkle-ized no hash do bloco. Isso nos permite\\nprovar a existência, mas não a não-existência de atualizações posteriores a um nome. Assim, nós\\nnão podemos saber com certeza o valor mais recente de um nome sem confiar em um\\nnó, ou recorrer a gastos significativos na largura de banda, baixando o\\nBlockchain.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Mesmo se uma árvore de pesquisa Merkle-ized for implementada na NameCoin, sua dependência\\nsobre a prova-de-trabalho torna a verificação do cliente light problemática. Os clientes light devem\\nbaixar uma cópia completa dos cabeçalhos para todos os blocos em toda a blockchain\\n(ou pelo menos todos os cabeçalhos desde a última atualização de um nome). Isso significa que\\nos requisitos de largura de banda crescem linearmente com a o passar do tempo \"\n        ),\n        _c(\n          \"a\",\n          {\n            attrs: { href: \"https://en.bitcoin.it/wiki/Thin_Client_Security\" },\n          },\n          [_vm._v(\"[21]\")]\n        ),\n        _vm._v(\n          \".\\nAlém disso, as mudanças de nome em um bloco de prova-de-trabalho requerem\\na confirmação do trabalho, o que pode levar até uma hora\\nno Bitcoin.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Com Tendermint, tudo o que precisamos é o hash de bloco mais recente assinado por um quorum de\\nvalidadores (por poder de voto), e uma prova Merkle para o valor atual associado\\ncom o nome. Isto torna possível ter uma solução sucinta, rápida e segura\\npara a verificação de valores de nome no cliente light.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Na Cosmos, podemos aplicar este conceito e estendê-lo ainda mais. Cada\\nzona de registro de nomes na Cosmos pode ter um domínio de nível superior (TLD)\\nassociado, como o “.com” ou “.org”, e cada zona de registro de nome pode ter\\nsuas próprias regras de governança e registro.\"\n        ),\n      ]),\n      _c(\"h2\", { attrs: { id: \"emissao-e-incentivos\" } }, [\n        _vm._v(\"Emissão e Incentivos\"),\n      ]),\n      _c(\"h3\", { attrs: { id: \"o-token-atom\" } }, [_vm._v(\"O Token Atom\")]),\n      _c(\"p\", [\n        _vm._v(\n          \"Enquanto o Cosmos Hub é um ledger de distribuíção multi-asset, há um token nativo\\nespecial chamado \"\n        ),\n        _c(\"em\", [_vm._v(\"atom\")]),\n        _vm._v(\n          \". Os atoms são o únicos símbolos do Cosmos\\nHub. Os atoms são uma licença para o titular votar, validar ou delegar\\nvalidadores. Como o ether da Ethereum, os atoms também podem ser usados para\\nreduzir o spam. Atoms inflacionários adicionais e as taxas do bloco de transação\\nsão recompensadas pelos validadores e delegados que\\no validarão.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"A transação \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"BurnAtomTx\")]),\n        _vm._v(\n          \" pode ser usada para cobrir proporcionalmente a quantidade\\nde tokens reservados para a pool.\"\n        ),\n      ]),\n      _c(\"h4\", { attrs: { id: \"levantamento-de-fundos\" } }, [\n        _vm._v(\"Levantamento de Fundos\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"A distribuição inicial dos tokens atom e validadores na Genesis vão para os\\ndoadores do Levantamento de Fundos da Cosmos (75%), doadores pesados (5%), Fundação da Rede\\nCosmos (10%), e a ALL IN BITS, Inc (10%). A partir da Genesis em diante, 1/3 da\\nquantidade total de atoms será recompensada aos validadores e delegados durante\\ntodo o ano.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Veja o \"),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://github.com/cosmos/cosmos/blob/master/PLAN.md\",\n            },\n          },\n          [_vm._v(\"Plano Cosmos\")]\n        ),\n        _vm._v(\"\\npara detalhes adicionais.\"),\n      ]),\n      _c(\"h4\", { attrs: { id: \"investindo\" } }, [_vm._v(\"Investindo\")]),\n      _c(\"p\", [\n        _vm._v(\n          \"Para evitar que o levantamento de fundos atraia especuladores de curto prazo apenas interessados\\nem esquemas de pump and dump, os atoms da Genesis não serão transferíveis até\\neles tenham investido. Cada conta irá adquirir atoms durante um período de 2 anos com\\ntaxa constante a cada hora, determinada pelo número total de atoms da Genesis/(2*\\n365 * 24) horas. Os atoms ganhos pela recompensa do bloco são pré-investidos,\\ne podem ser transferidos imediatamente, de modo que os validadores e os delegados ligados possam ganhar\\nmais da metade de seus atoms da Genesis após o primeiro ano.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"limitacoes-do-numero-de-validadores\" } }, [\n        _vm._v(\"Limitações do Número de Validadores\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Diferentemente do Bitcoin ou de outros blockchains de prova-de-trabalho, o blockchain Tendermint será\\nmais lento com mais validadores devido ao aumento da complexidade da comunicação.\\nFelizmente, podemos oferecer suporte a validadores suficientes para a\\ndistribuição na Blockchain com tempos de confirmação de transação muito mais rápidos e, através de\\nlargura de banda, armazenamento e aumento da capacidade de computação paralela, seremos capazes de\\nter mais validadores no futuro.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"No dia da Genesis, o número máximo de validadores será definido como 100,\\no número aumentará a uma taxa de 13% durante 10 anos até atingir a marca de 300\\nValidadores.\"\n        ),\n      ]),\n      _c(\"pre\", { pre: true }, [\n        _c(\"code\", { pre: true, attrs: { \"v-pre\": \"\" } }, [\n          _vm._v(\n            \"Ano 0: 100\\nAno 1: 113\\nAno 2: 127\\nAno 3: 144\\nAno 4: 163\\nAno 5: 184\\nAno 6: 208\\nAno 7: 235\\nAno 8: 265\\nAno 9: 300\\nAno 10: 300\\n...\\n\"\n          ),\n        ]),\n      ]),\n      _c(\n        \"h3\",\n        { attrs: { id: \"tornando-se-um-validador-depois-do-dia-da-genesis\" } },\n        [_vm._v(\"Tornando-se um Validador depois do dia da Genesis\")]\n      ),\n      _c(\"p\", [\n        _vm._v(\n          \"Os titulares de atoms que ainda não são capazes de se tornarem validadores assinados e\\nsubmeter uma transação \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"BondTx\")]),\n        _vm._v(\n          \". A quantidade de atoms fornecida como garantia\\ndeve ser diferente de zero. Qualquer pessoa pode se tornar um validador a qualquer momento, exceto quando o\\ntamanho do conjunto de validadores atual é maior que o número máximo de\\nvalidadores permitidos. Nesse caso, a transação só é válida se o montante\\nde atoms é maior do que a quantidade de atoms efetivos mantidos pelo menor\\nvalidador, onde atoms eficazes incluem atoms delegados. Quando um novo validador\\nsubstitui um validador existente de tal forma, o validador existente torna-se\\ninativo e todos os atoms e atoms delegados entram no estado de unbonding.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"penalidades-para-validadores\" } }, [\n        _vm._v(\"Penalidades para Validadores\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Deve haver alguma penalidade imposta aos validadores por qualquer desvio intencional\\nou não intencional do protocolo sancionado. Algumas evidências são imediatamente admissíveis,\\ncomo um double-sign na mesma altura e volta, ou uma violação de “prevote-the-lock”\\n(uma regra do protocolo de consenso Tendermint). Tais evidências resultarão em que o\\nvalidador perca sua boa reputação e seus átomos ligados, bem como sua proporção de tokens\\nna pool reserva - coletivamente chamados de “stake” - serão cortados.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Às vezes, os validadores não estarão disponíveis, devido a interrupções na rede regional,\\nfalha de energia ou outros motivos. Se, em qualquer ponto nos blocos \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"ValidatorTimeoutWindow\")]),\n        _vm._v(\n          \"\\nanteriores, o voto de validação de um validador não estiver incluído na cadeia de\\nblocos mais do que \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"ValidatorTimeoutMaxAbsent\")]),\n        _vm._v(\" vezes, esse validador ficará inativo e\\nperderá \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"ValidatorTimeoutPenalty\")]),\n        _vm._v(\" (PADRÃO DE 1%) de sua participação.\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Alguns comportamentos “maliciosos” não produzem provas obviamente discerníveis sobre\\na blockchain. Nesses casos, os validadores podem coordenar fora da banda para forçar\\no tempo limite desses validadores maliciosos, se houver um consenso majoritário.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Em situações em que o Cosmos Hub parar devido a uma coalizão de ⅓+ de poder de voto\\noffline, ou em situações onde uma coalizão de ⅓+ de poder de voto censurar evidências de\\ncomportamento malicioso entrando na blockchain, o hub deve recuperar com um hard-fork\\nde proposta reorganizacional. (Link to “Forks and Censorship Attacks”).\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"taxas-de-transacao\" } }, [\n        _vm._v(\"Taxas de Transação\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Os validadores do Cosmos Hub podem aceitar qualquer tipo de token ou combinação\\nde tipos como taxas para processar uma transação. Cada validador pode fixar subjetivamente a\\ntaxa de câmbio que quiser e escolher as transações que desejar, desde que o \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"BlockGasLimit\")]),\n        _vm._v(\n          \"\\nnão seja excedido. As taxas cobradas, menos quaisquer impostos especificados abaixo,\\nsão redistribuídas aos stakeholders ligados em proporção aos seus átomos ligados, cada \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"ValidatorPayoutPeriod\")]),\n        _vm._v(\" (PADRÃO DE 1 hora).\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Das taxas de transação cobradas, \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"ReserveTax\")]),\n        _vm._v(\n          \" (PADRÃO DE 2%) irá para a pool reserva\\npara aumentar a pool reserva e aumentar a segurança e o valor da rede Cosmos. Além disso, um\\n\"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"CommonsTax\")]),\n        _vm._v(\n          \" (PADRÃO DE 3%) irá para o financiamento de bens comuns. Estes fundos vão para o\\n\"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"CustodianAddress\")]),\n        _vm._v(\n          \" para ser distribuído de acordo com as decisões tomadas pelo sistema de governança.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Os titulares de átomos que delegam o seu poder de voto a outros validadores pagam uma comissão\\nao validador delegado. A comissão pode ser definida por cada validador.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"incentivando-hackers\" } }, [\n        _vm._v(\"Incentivando Hackers\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"A segurança do Cosmos Hub é uma função da segurança dos validadores subjacentes e da escolha\\nda delegação pelos delegados. A fim de incentivar a descoberta e notificação precoce de vulnerabilidades\\nencontradas, o Cosmos Hub incentiva os hackers a publicar exploits bem sucedidos através de uma transação\\n\"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"ReportHackTx\")]),\n        _vm._v(\n          ' que diz,\" Este validador foi hackeado. Por favor, envie recompensa para este endereço\".\\nDepois de tal exploração, o validador e os delegados ficarão inativos, '\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"HackPunishmentRatio\")]),\n        _vm._v(\" (PADRÃO DE 5%)\\ndos átomos de todos serão cortados, e\"),\n        _c(\"code\", { pre: true }, [_vm._v(\"HackRewardRatio\")]),\n        _vm._v(\n          \" (PADRÃO DE 5%) dos átomos de todos\\nserão recompensado com o endereço de recompensa do hacker. O validador deve recuperar os átomos\\nrestantes usando sua chave de backup.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Para evitar que esse recurso seja abusado para transferir átomos não invadidos,\\na porção de átomos adquirido vs relativo de validadores e delegados antes e depois do \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"ReportHackTx\")]),\n        _vm._v(\n          \"\\npermanecerá o mesmo, e o bounty do hacker irá incluir alguns átomos relativos, se houver.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"especificacao-de-governanca\" } }, [\n        _vm._v(\"Específicação de Governança\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"O Cosmos Hub é operado por uma organização distribuída que requer um mecanismo de\\ngovernança bem definido para coordenar várias mudanças na blockchain, como parâmetros\\nvariáveis do sistema, bem como atualizações de software e emendas constitucionais.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Todos os validadores são responsáveis por votar em todas as propostas.\\nNão votar em uma proposta em tempo hábil resultará na desativação automática do\\nvalidador por um período de tempo denominado \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"AbsenteeismPenaltyPeriod\")]),\n        _vm._v(\" (PADRÃO DE 1 semana).\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Os delegados herdam automaticamente o voto do validador delegado.\\nEste voto pode ser anulado manualmente. Os átomos não ligados obtêm nenhum voto.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Cada proposta requer um depósito de tokens de \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"MinimumProposalDeposit\")]),\n        _vm._v(\n          \",\\nque pode ser uma combinação de um ou mais tokens incluindo átomos.\\nPara cada proposta, os eleitores podem votar para receber o depósito.\\nSe mais da metade dos eleitores optarem por receber o depósito (por exemplo, porque a proposta era spam),\\no depósito vai para a pool reserva, exceto os átomos que são queimados.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Para cada proposta, os eleitores podem votar nas seguintes opições:\"\n        ),\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [_vm._v(\"Sim\")]),\n        _c(\"li\", [_vm._v(\"Com Certeza\")]),\n        _c(\"li\", [_vm._v(\"Não\")]),\n        _c(\"li\", [_vm._v(\"Nunca\")]),\n        _c(\"li\", [_vm._v(\"Abstenção\")]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"É necessário uma maioria estrita de votos Yea(Sim) ou YeaWithForce(Com certeza)\\n(ou votos Nay(Não) ou NayWithForce(Nunca)) para que a proposta seja decidida como aceita\\n(ou decidida como falha), mas 1/3+ pode vetar a decisão da maioria votando “Com certeza”.\\nQuando uma maioria estrita é vetada, todos são punidos com a perda de \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"VetoPenaltyFeeBlocks\")]),\n        _vm._v(\n          \"\\n(PADRÃO DE no valor de um dia de blocos) de taxas (exceto os impostos que não serão afetados),\\ne a parte que vetou a decisão da maioria será adicionalmente punida com a perda de \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"VetoPenaltyAtoms\")]),\n        _vm._v(\"\\n(PADRÃO DE 0.1%) de seus átomos.\"),\n      ]),\n      _c(\"h3\", { attrs: { id: \"parametro-de-mudanca-de-proposta\" } }, [\n        _vm._v(\"Parâmetro de Mudança de Proposta\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Qualquer um dos parâmetros aqui definidos pode ser alterado com a aceitação\\nde um \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"ParameterChangeProposal\")]),\n        _vm._v(\".\"),\n      ]),\n      _c(\"h3\", { attrs: { id: \"texto-da-proposta\" } }, [\n        _vm._v(\"Texto da Proposta\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Todas as outras propostas, como uma proposta de atualização do protocolo, serão coordenadas através do genérico \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"TextProposal\")]),\n        _vm._v(\".\"),\n      ]),\n      _c(\"h2\", { attrs: { id: \"roteiro\" } }, [_vm._v(\"Roteiro\")]),\n      _c(\"p\", [\n        _vm._v(\"Veja \"),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://github.com/cosmos/cosmos/blob/master/PLAN.md\",\n            },\n          },\n          [_vm._v(\"o Plano Cosmos\")]\n        ),\n        _vm._v(\".\"),\n      ]),\n      _c(\"h2\", { attrs: { id: \"trabalho-relacionado\" } }, [\n        _vm._v(\"Trabalho Relacionado\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Houve muitas inovações no consenso da blockchain e na escalabilidade nos últimos dois anos.\\nEsta seção fornece um breve levantamento de um seleto número das mais importantes.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"sistemas-de-consenso\" } }, [\n        _vm._v(\"Sistemas de Consenso\"),\n      ]),\n      _c(\"h4\", { attrs: { id: \"classic-byzantine-fault-tolerance\" } }, [\n        _vm._v(\"Classic Byzantine Fault Tolerance\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Consenso na presença de participantes maliciosos é um problema que remonta ao início dos anos 1980,\\nquando Leslie Lamport cunhou a frase “falha bizantina” para se referir ao comportamento do processo\\narbitrário que se desvia do comportamento pretendido, que contraste com uma “falha acidental”,\\nem que um processo simplesmente falha. Soluções iniciais foram descobertas para redes síncronas onde\\nhá um limite superior na latência da mensagem, embora o uso prático fosse limitado a ambientes altamente controlados,\\ncomo controladores de avião e datacenters sincronizados via relógios atômicos.\\nNão foi até o final dos anos 90 que a Practical Byzantine Fault Tolerance (PBFT) foi introduzida como\\num eficiente algoritmo de consenso parcialmente síncrono capaz de tolerar até ⅓ de processos\\ncomportando-se arbitrariamente. PBFT tornou-se o algoritmo padrão, gerando muitas variações,\\nincluindo mais recentemente uma criada pela IBM como parte de sua contribuição para a Hyperledger.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"O principal benefício do consenso Tendermint sobre PBFT é que o Tendermint tem uma estrutura\\nsubjacente melhorada e simplificada, um dos quais é um resultado de adotar o paradigma blockchain.\\nBlocos Tendermint devem confirmar em ordem, o que evita a complexidade e sobrecarga de comunicação\\nassociada a alteração de visão do PBFT’s. No Cosmos e muitas outras criptomoedas,\\nnão há necessidade de permitir o bloco \"\n        ),\n        _c(\"em\", [_vm._v(\"N+i\")]),\n        _vm._v(\" onde \"),\n        _c(\"em\", [_vm._v(\"i >= 1\")]),\n        _vm._v(\" se confirmar,\\nquando o próprio bloco \"),\n        _c(\"em\", [_vm._v(\"N\")]),\n        _vm._v(\n          \" ainda não se confirmou. Se a largura de banda é a razão\\npela qual o bloco \"\n        ),\n        _c(\"em\", [_vm._v(\"N\")]),\n        _vm._v(\n          \" não se confirmou em uma zona do Cosmos, então isso não ajuda\\na usar os votos de compartilhamento de largura de banda para blocos \"\n        ),\n        _c(\"em\", [_vm._v(\"N+i\")]),\n        _vm._v(\n          \".\\nSe uma partição de rede ou nós offline for a razão pela qual o bloco \"\n        ),\n        _c(\"em\", [_vm._v(\"N\")]),\n        _vm._v(\" não foi confirmado,\\n\"),\n        _c(\"em\", [_vm._v(\"N+i\")]),\n        _vm._v(\" não se comprometerá de qualquer maneira.\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Além disso, o lote de transações em blocos permite que o Merkle-hashing regule o estado da aplicação,\\nao invés de resumos periódicos com esquemas de pontos de verificação como PBFT faz.\\nIsso permite confirmações de transações mais rápidas para clientes leves e uma comunicação mais rápida entre a blockchain.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Tendermint BFT também inclui muitas otimizações e recursos que vão acima e além do que é especificado no PBFT.\\nPor exemplo, os blocos propostos pelos validadores são divididos em partes,\\nMerkleized e inútilizados de tal forma que melhora o desempenho da transmissão\\n(ver LibSwift \"\n        ),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"http://www.ds.ewi.tudelft.nl/fileadmin/pds/papers/PerformanceAnalysisOfLibswift.pdf\",\n            },\n          },\n          [_vm._v(\"[19]\")]\n        ),\n        _vm._v(\n          \" para inspiração). Além disso, Tendermint BFT não faz qualquer suposição sobre\\na conectividade ponto-a-ponto, e funciona durante o tempo que a rede P2P está fracamente conectada.\"\n        ),\n      ]),\n      _c(\"h4\", { attrs: { id: \"participacao-delegada-do-bitshares\" } }, [\n        _vm._v(\"Participação delegada do BitShares\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Apesar de não serem os primeiros a implementar a prova-de-participação (Proof-of-Stake - PoS),\\no BitShares \"\n        ),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://bitshares.org/technology/delegated-proof-of-stake-consensus/\",\n            },\n          },\n          [_vm._v(\"[12]\")]\n        ),\n        _vm._v(\n          \" contribuiu consideravelmente para a pesquisa e adoção das blockchains que usam o PoS,\\nparticularmente aqueles conhecidos como PoS “delegados”. No BitShares, as partes interessadas elegem “testemunhas”,\\nresponsáveis por ordenar e confirmar transações e “delegados”, responsáveis pela coordenação\\nde atualizações de software e alterações de parâmetros. Embora o BitShares atinja alto desempenho\\n(100k tx/s, 1s de latência) em condições ideais, ele está sujeito a ataques de duplo gasto por testemunhas\\nmaliciosas que “forkem” a blockchain sem sofrer uma punição econômica explícita - ele sofre do problema\\n“nada a perder”. O BitShares tenta suavizar o problema permitindo que as transações se refiram a\\nblocos-hashes recentes. Além disso, as partes interessadas podem remover ou substituir\\ntestemunhas de má conduta diariamente, embora isso não faça nada para punir\\nexplicitamente os ataques bem sucedidos de duplo gasto.\"\n        ),\n      ]),\n      _c(\"h4\", { attrs: { id: \"stellar\" } }, [_vm._v(\"Stellar\")]),\n      _c(\"p\", [\n        _vm._v(\"Baseando-se em uma abordagem pioneira da Ripple, a Stellar \"),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://www.stellar.org/papers/stellar-consensus-protocol.pdf\",\n            },\n          },\n          [_vm._v(\"[13]\")]\n        ),\n        _vm._v(\n          \" refinou um modelo do\\nFederated Byzantine Agreement em que os processos que participam do consenso não constituem\\num conjunto fixo e globalmente conhecido. Em vez disso, cada nó de processo codifica uma ou mais\\n“fatias de quórum”, cada uma constituindo um conjunto de processos confiáveis. Um “quórum” na\\nStellar é definido como um conjunto de nós que contêm pelo menos uma fatia de quórum para cada\\nnó no conjunto, de modo que o acordo possa ser alcançado.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"A segurança do mecanismo Stellar baseia-se no pressuposto de que a intersecção de \"\n        ),\n        _c(\"em\", [_vm._v(\"qualquer\")]),\n        _vm._v(\n          \" dois\\nquóruns é não-vazia, enquanto a disponibilidade de um nó requer pelo menos uma das suas fatias de\\nquórum para consistir inteiramente de nós corretos, criando um troca externa entre o uso de grandes\\nou pequenas fatias-quórum que podem ser difíceis de equilíbrar sem impor pressupostos significativos\\nsobre a confiança. Em última análise, os nós precisam, de alguma forma, escolher fatias de quórum adequadas\\npara que haja tolerância suficiente a falhas (ou qualquer “nó intacto” em geral, do qual muitos dos\\nresultados do trabalho dependem) e a única estratégia fornecida para garantir tal configuração é\\nhierárquica e similar ao Border Gateway Protocol (BGP), usado por ISPs de primeira linha na\\ninternet para estabelecer tabelas de roteamento globais e usado pelos navegadores para gerenciar\\ncertificados TLS; Ambos notórios por sua insegurança.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"A crítica sobre papel da Stellar nos sistemas PoS baseados em Tendermint é atenuada pela estratégia\\nde token descrita aqui, em que um novo tipo de token chamado \"\n        ),\n        _c(\"em\", [_vm._v(\"atom\")]),\n        _vm._v(\n          \" é emitido para representar\\nreivindicações para futuras porções de taxas e recompensas. A vantagem do PoS baseado em Tendermint,\\nportanto, é a sua relativa simplicidade, ao mesmo tempo que oferece garantias de segurança suficientes e prováveis.\"\n        ),\n      ]),\n      _c(\"h4\", { attrs: { id: \"bitcoinng\" } }, [_vm._v(\"BitcoinNG\")]),\n      _c(\"p\", [\n        _vm._v(\n          \"O BitcoinNG é uma proposta de melhoria do Bitcoin que permitiria formas de escalabilidade vertical,\\ncomo o aumento do tamanho do bloco, sem as conseqüências econômicas negativas normalmente associadas a tal mudança,\\ncomo o impacto desproporcionalmente grande sobre os pequenos mineradores. Esta melhoria é conseguida separando\\na eleição do líder da transmissão da transação: os líderes são eleitos pela primeira vez\\npor prova de trabalho(PoW) em “microblocos”, e então são capazes de transmitir transações a\\nserem confirmadas até que um novo microbloco seja encontrado. Isso reduz os requisitos\\nde largura de banda necessários para vencer a corrida PoW, permitindo que os pequenos\\nmineiros possam competir mais justamente, e permitindo que as transações sejam confirmadas\\ncom mais regularidade pelo último minerador para encontrar um micro-bloco.\"\n        ),\n      ]),\n      _c(\"h4\", { attrs: { id: \"casper\" } }, [_vm._v(\"Casper\")]),\n      _c(\"p\", [\n        _vm._v(\"Casper \"),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://blog.ethereum.org/2015/08/01/introducing-casper-friendly-ghost/\",\n            },\n          },\n          [_vm._v(\"[16]\")]\n        ),\n        _vm._v(\n          \" é uma proposta de algoritmo de consenso PoS para o Ethereum.\\nSeu modo principal de operação é “consenso-por-aposta”. Ao permitir que os validadores apostem\\niterativamente em qual bloco eles acreditam que será confirmado na blockchain com base nas\\noutras apostas que eles têm visto até agora, a finalidade pode ser alcançada eventualmente.\\n\"\n        ),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://blog.ethereum.org/2015/12/28/understanding-serenity-part-2-casper/\",\n            },\n          },\n          [_vm._v(\"link\")]\n        ),\n        _vm._v(\n          \". Esta é uma área ativa\\nde pesquisa da equipe de Casper. O desafio está na construção de um mecanismo de apostas que pode ser\\ncomprovado como uma estratégia evolutivamente estável. O principal benefício da Casper em relação à\\nTendermint pode ser a oferta de “disponibilidade sobre a consistência” - consenso não requer\\num quórum +⅔ de poder de voto - talvez ao custo de velocidade de confirmação ou complexidade de implementação.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"escala-horizontal\" } }, [\n        _vm._v(\"Escala Horizontal\"),\n      ]),\n      _c(\"h4\", { attrs: { id: \"protocolo-interledger\" } }, [\n        _vm._v(\"Protocolo Interledger\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"O Protocolo Interledger \"),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://interledger.org/rfcs/0001-interledger-architecture/\",\n            },\n          },\n          [_vm._v(\"[14]\")]\n        ),\n        _vm._v(\n          \" não é estritamente uma solução de escalabilidade.\\nEle fornece uma interoperabilidade ad hoc entre diferentes sistemas de ledger através de uma rede\\nde relações bilaterais livremente acopladas. Tal como a Lightning Network, a finalidade do\\nILP é facilitar pagamentos, mas focaliza especificamente pagamentos em diferentes tipos de ledger,\\nestendendo o mecanismo de transações atômicas para incluir não apenas hash-locks, mas também um\\nquórum de notários (chamado de Atomic Transport Protocol). O último mecanismo para reforçar a\\natomicidade em transacções entre-ledger é semelhante ao mecanismo SPV do cliente leve do Tendermint,\\nentão uma ilustração da distinção entre ILP e Cosmos/IBC é garantida, e fornecida abaixo.\"\n        ),\n      ]),\n      _c(\"ol\", [\n        _c(\"li\", [\n          _c(\"p\", [\n            _vm._v(\n              \"Os notários de um conector em ILP não suportam mudanças de consentimento, e não permitem uma\\npesagem flexível entre notários. Por outro lado, o IBC é projetado especificamente para blockchains,\\nonde os validadores podem ter diferentes pesos, e onde o consentimento pode mudar ao longo da cadeia de blocos.\"\n            ),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"p\", [\n            _vm._v(\n              \"Como na Lightning Network, o receptor do pagamento em ILP deve estar on-line para enviar\\numa confirmação de volta ao remetente. Em uma transferência de token sobre IBC, o conjunto\\nde validadores da blockchain do receptor é responsável por fornecer a confirmação, não o usuário receptor.\"\n            ),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"p\", [\n            _vm._v(\n              \"A diferença mais notável é que os conectores do ILP não são responsáveis ou mantêm o estado\\nautoritário sobre os pagamentos, enquanto que no Cosmos, os validadores de um hub são a autoridade\\ndo estado das transferências de tokens do IBC, bem como a autoridade da quantidade de tokens\\nmantidos por cada zona (mas não a quantidade de tokens mantidos por cada conta dentro de uma zona).\\nEsta é a inovação fundamental que permite a tranferência assimétrica segura de tokens de zona para\\nzona; O conector analógico do ILP no Cosmos é uma persistente e maximamente segura ledger de blockchain, o Cosmos Hub.\"\n            ),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"p\", [\n            _vm._v(\n              \"Os pagamentos entre contas no ILP precisam ser suportados por uma ordem de compra/venda, uma\\nvez que não há transferência assimétrica de moedas de um ledger para outro, apenas a transferência\\nde valor ou equivalentes de mercado.\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"h4\", { attrs: { id: \"sidechains\" } }, [_vm._v(\"Sidechains\")]),\n      _c(\"p\", [\n        _vm._v(\"Sidechains \"),\n        _c(\"a\", { attrs: { href: \"https://blockstream.com/sidechains.pdf\" } }, [\n          _vm._v(\"[15]\"),\n        ]),\n        _vm._v(\n          \" são um mecanismo proposto para dimensionar a rede Bitcoin através de\\nblockchains alternativas que são “atreladas” para a blockchain do Bitcoin. As Sidechains\\npermitem que bitcoins se movam efetivamente da blockchain do Bitcoin para a sidechain e retornarem,\\ne permitem a experimentação em novos recursos na sidechain. Como no Cosmos Hub, a sidechain e\\nBitcoin servem como clientes leves uns dos outros, usando provas SPV para determinar quando as moedas\\ndevem ser transferidas para a cadeia lateral e retornarem. Claro, como o Bitcoin usa PoW, sidechains\\ncentradas em torno do Bitcoin sofrem dos muitos problemas e riscos do PoW como um mecanismo de consenso.\\nAlém disso, esta é uma solução Bitcoin-maximalista que não suporta nativamente uma variedade de tokens e\\ntopologia de rede entre-zona como o Cosmos faz. Dito isto, o mecanismo de núcleo bidirecional atrelado é,\\nem princípio, o mesmo que o empregado pela rede Cosmos.\"\n        ),\n      ]),\n      _c(\"h4\", { attrs: { id: \"esforcos-de-escalabilidade-do-ethereum\" } }, [\n        _vm._v(\"Esforços de Escalabilidade do Ethereum\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Ethereum está atualmente pesquisando uma série de estratégias diferentes para fragmentar o\\nestado da blockchain do Ethereum para atender às necessidades de escalabilidade.\\nEsses esforços têm como objetivo manter a camada de abstração oferecida pela atual\\nEthereum Virtual Machine através do espaço de estado compartilhado. Vários esforços de\\npesquisa estão em andamento neste momento. \"\n        ),\n        _c(\n          \"a\",\n          { attrs: { href: \"https://github.com/ethereum/EIPs/issues/53\" } },\n          [_vm._v(\"[18]\")]\n        ),\n        _c(\n          \"a\",\n          { attrs: { href: \"http://vitalik.ca/files/mauve_paper.html\" } },\n          [_vm._v(\"[22]\")]\n        ),\n      ]),\n      _c(\"h5\", { attrs: { id: \"cosmos-vs-ethereum-20-mauve\" } }, [\n        _vm._v(\"Cosmos vs Ethereum 2.0 Mauve\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Cosmos e Ethereum 2.0 Mauve \"),\n        _c(\n          \"a\",\n          { attrs: { href: \"http://vitalik.ca/files/mauve_paper.html\" } },\n          [_vm._v(\"[22]\")]\n        ),\n        _vm._v(\" tem diferentes objetivos de projeto.\"),\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\n            \"Cosmos é especificamente sobre tokens. Malva é sobre escalonamento de computação geral.\"\n          ),\n        ]),\n        _c(\"li\", [\n          _vm._v(\n            \"O Cosmos não está ligado ao EVM, por isso mesmo VMs diferentes podem interoperar.\"\n          ),\n        ]),\n        _c(\"li\", [\n          _vm._v(\n            \"Cosmos permite que o criador da zona determine quem valida a zona.\"\n          ),\n        ]),\n        _c(\"li\", [\n          _vm._v(\n            \"Qualquer pessoa pode iniciar uma nova zona no Cosmos (a menos que a governança decida o contrário).\"\n          ),\n        ]),\n        _c(\"li\", [\n          _vm._v(\n            \"O hub isola falhas de zonas de modo que tokens invariantes sejam preservados.\"\n          ),\n        ]),\n      ]),\n      _c(\"h3\", { attrs: { id: \"escala-geral\" } }, [_vm._v(\"Escala Geral\")]),\n      _c(\"h4\", { attrs: { id: \"lightning-network\" } }, [\n        _vm._v(\"Lightning Network\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"A Lightning Network é uma proposta de rede de transferência de token operando em uma camada acima\\nda blockchain do Bitcoin (e outras blockchains públicas), permitindo a melhoria de muitas ordens\\nde magnitude no processamento de transações movendo a maioria das transações fora da ledger de consenso\\npara o chamado “Canais de pagamento”. Isso é possível graças a scripts de criptomoedas em cadeia,\\nque permitem que as partes entrem em contratos estatais bilaterais onde o estado pode ser atualizado\\ncompartilhando assinaturas digitais, e os contratos podem ser fechados definitivamente publicando\\nevidências na blockchain, um mecanismo primeiramente popularizado por trocas atômicas de\\ncross-chains(cadeias cruzadas). Ao abrir canais de pagamento com muitas partes, os participantes\\nda Lightning Network podem se tornar pontos focais para encaminhar os pagamentos de outros,\\nlevando a uma rede de canais de pagamento totalmente conectada, ao custo do capital estar ligado aos canais de pagamento.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Enquanto a Lightning Network também pode facilmente se estender através de várias blockchains independentes\\npara permitir a transferência de \"\n        ),\n        _c(\"em\", [_vm._v(\"value\")]),\n        _vm._v(\n          \" através de um mercado de câmbio, não pode ser usado para\\ntransferir assimetricamente \"\n        ),\n        _c(\"em\", [_vm._v(\"tokens\")]),\n        _vm._v(\n          \" de uma blockchain para outra. O principal benefício da rede Cosmos\\ndescrita aqui é permitir tais transferências diretas de tokens. Dito isto, esperamos que os canais de\\npagamento e a Lightning Network sejam amplamente adotados juntamente com nosso mecanismo de transferência\\nde token, por razões de economia de custos e privacidade.\"\n        ),\n      ]),\n      _c(\"h4\", { attrs: { id: \"segregated-witness\" } }, [\n        _vm._v(\"Segregated Witness\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Segregated Witness é uma proposta de melhoria do Bitcoin\\n\"),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki\",\n            },\n          },\n          [_vm._v(\"link\")]\n        ),\n        _vm._v(\n          \" que visa aumentar em 2X ou 3X a\\ntaxa de transferência por bloco, ao mesmo tempo que faz a sincronização de blocos ser mais rapida para\\nnovos nós. O brilho desta solução é de como ele funciona dentro das limitações do protocolo atual do Bitcoin\\ne permite uma atualização de soft-fork (ou seja, os clientes com versões mais antigas do software\\ncontinuarão funcionando após a atualização). O Tendermint, sendo um novo protocolo, não tem restrições\\nde projeto, por isso tem prioridades diferentes de escalonamento. Sobretudo, o Tendermint usa um algoritmo\\nde rodízio BFT baseado em assinaturas criptográficas em vez de mineração, o que trivialmente permite escalonamento\\nhorizontal através de múltiplas blockchains paralelas, enquanto que os regulares e mais frequentes blocos confirmam\\na escala vertical também.\"\n        ),\n      ]),\n      _c(\"hr\"),\n      _c(\"h2\", { attrs: { id: \"apendice\" } }, [_vm._v(\"Apêndice\")]),\n      _c(\"h3\", { attrs: { id: \"responsabilidade-de-fork\" } }, [\n        _vm._v(\"Responsabilidade de Fork\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Um protocolo de consenso bem projetado deve fornecer algumas garantias no caso da capacidade de\\ntolerância ser excedida e o consenso falhar. Isto é especialmente necessário nos sistemas econômicos,\\nonde o comportamento Bizantino pode ter recompensa financeira substancial. A\\ngarantia maisimportante é uma forma de \"\n        ),\n        _c(\"em\", [_vm._v(\"fork-accountability\")]),\n        _vm._v(\n          \", onde os processos que\\nfizeram com que o consenso falhasse (ou seja, clientes do protocolo\\nmotivados para aceitar valores diferentes - um fork) podem ser identificados e punidos de acordo com as\\nregras do protocolo , Ou, possivelmente, o sistema jurídico. Quando o sistema jurídico não é confiável\\nou é excessivamente caro para suplicar, os validadores podem ser forçados a fazerem depósitos de segurança\\npara participar, e esses depósitos podem ser revogados ou cortados, quando um comportamento malicioso é detectado \"\n        ),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://blog.ethereum.org/2014/01/15/slasher-a-punitive-proof-of-stake-algorithm/\",\n            },\n          },\n          [_vm._v(\"[10]\")]\n        ),\n        _vm._v(\".\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Observe que isso é diferente do Bitcoin, onde o fork é uma ocorrência regular devido à assincronia de\\nrede e à natureza probabilística de encontrar colisões de hash parciais. Uma vez que, em muitos casos,\\num fork malicioso é indistinguível de um fork devido à assincronia, o Bitcoin não pode implementar de\\nforma confiável a responsabilidade de um fork, com exceção do custo implícito pago por mineradores que\\ntem a oportunidade de minerarem um bloco órfão.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"consenso-tendermint\" } }, [\n        _vm._v(\"Consenso Tendermint\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Chamamos as fases de votação de \"),\n        _c(\"em\", [_vm._v(\"PreVote\")]),\n        _vm._v(\" e \"),\n        _c(\"em\", [_vm._v(\"PreCommit\")]),\n        _vm._v(\". Um voto pode ser para um bloco em particular ou\\npara \"),\n        _c(\"em\", [_vm._v(\"Nil\")]),\n        _vm._v(\n          \". Chamamos uma coleção de +⅔ PreVotes para um único bloco na mesma rodada de um \"\n        ),\n        _c(\"em\", [_vm._v(\"Polka\")]),\n        _vm._v(\n          \", e uma\\ncoleção de +⅔ PreCommits para um único bloco na mesma rodada de um \"\n        ),\n        _c(\"em\", [_vm._v(\"Commit\")]),\n        _vm._v(\n          \". Se +⅔ PreCommit para Nil na\\nmesma rodada, eles passam para a próxima rodada.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Observe que o determinismo estrito no protocolo incorre em uma suposição de sincronia fraca, pois os líderes\\ncom falhas devem ser detectados e ignorados. Assim, os validadores aguardam algum tempo, \"\n        ),\n        _c(\"em\", [_vm._v(\"TimeoutPropose\")]),\n        _vm._v(\n          \",\\nantes de Prevote Nil, e o valor de TimeoutPropose aumenta a cada rodada. A progressão através do\\nresto de uma rodada é totalmente assincrôna, onde o progresso é feito somente quando um validador\\nouve de +⅔ da rede. Na prática, seria necessário um adversário extremamente forte para impedir\\nindefinidamente a suposição de sincronia fraca (fazendo com que o consenso deixasse de confirmar um bloco),\\ne isso pode ser ainda mais difícil usando valores randomizados de TimeoutPropose em cada validador.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Um conjunto adicional de restrições, ou Locking Rules(Regras de bloqueio), garante que a rede acabará\\npor confirmar apenas um bloco em cada altura. Qualquer tentativa maliciosa de confirmar de causar um\\nbloco a ser confirmado a uma determinada altura pode ser identificada. Primeiro, um PreCommit para um\\nbloco deve vir com justificação, na forma de um Polka para esse bloco. Se o validador já tiver PreCommit\\num bloco na rodada \"\n        ),\n        _c(\"em\", [\n          _vm._v(\"R\"),\n          _c(\"em\", [_vm._v(\"1\")]),\n          _vm._v(\", nós dizemos que eles estão _locked\"),\n        ]),\n        _vm._v(\n          \" nesse bloco, e o Polka usado\\npara justificar o novo PreCommit na rodada \"\n        ),\n        _c(\"em\", [_vm._v(\"R_2\")]),\n        _vm._v(\" deve vir de uma rodada \"),\n        _c(\"em\", [_vm._v(\"R_polka\")]),\n        _vm._v(\"\\nonde \"),\n        _c(\"em\", [_vm._v(\"R_1 < R_polka <= R_2\")]),\n        _vm._v(\n          \". Em segundo lugar, os validadores devem propor e/ou pré-votar\\no bloco que eles estão travados. Juntas, essas condições garantem que um validador não PreCommit\\nsem evidência suficiente como justificativa, e que os validadores que já têm PreCommit não podem\\ncontribuir para a evidência de PreCommit algo mais. Isso garante a segurança e a vivacidade do algoritmo de consenso.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Os detalhes completos do protocolo são descritos\\n\"),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://github.com/tendermint/tendermint/wiki/Byzantine-Consensus-Algorithm\",\n            },\n          },\n          [_vm._v(\"aqui\")]\n        ),\n        _vm._v(\".\"),\n      ]),\n      _c(\"h3\", { attrs: { id: \"clientes-leves-do-tendermint\" } }, [\n        _vm._v(\"Clientes Leves do Tendermint\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"A necessidade de sincronizar todos os cabeçalhos de bloco é eliminada no Tendermint-PoS, como por exemplo\\na existência de uma cadeia alternativa (um fork) significando que ⅓+ do stake ligado pode ser reduzido.\\nNaturalmente, a partir que dividir requer que \"\n        ),\n        _c(\"em\", [_vm._v(\"someone\")]),\n        _vm._v(\n          \" compartilhe evidência de um fork, clientes leves\\ndevem armazenar qualquer bloco-hash comprometido que eles vêem. Além disso, os clientes leves podem\\nperiodicamente ficarem sincronizados com as alterações no conjunto de validadores, para evitar\\n\"\n        ),\n        _c(\"a\", { attrs: { href: \"#preventing-long-range-attacks\" } }, [\n          _vm._v(\"ataques de longo alcance\"),\n        ]),\n        _vm._v(\" (mas outras soluções são possíveis).\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Em espírito semelhante do Ethereum, o Tendermint permite que os aplicativos incorporem um hash de raiz\\nMerkle global em cada bloco, permitindo verifícações fáceis de consultas de estado para fins como saldos\\nde contas, o valor armazenado em um contrato ou a existência de saída de uma transação não gasta,\\ndependendo da natureza da aplicação.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"prevencao-de-ataques-de-longo-alcance\" } }, [\n        _vm._v(\"Prevenção de ataques de longo alcance\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Assumindo uma coleção suficientemente elástica de redes de difusão e um conjunto de validador\\nestático, qualquer fork na blockchain pode ser detectado e os depósitos dos validadores ofensivos cortados.\\nEsta inovação, sugerida pela primeira vez por Vitalik Buterin no início de 2014, resolve o problema do “nada a perder” de outras\\ncriptomoedas de PoW (ver \"\n        ),\n        _c(\"a\", { attrs: { href: \"#related-work\" } }, [\n          _vm._v(\"Trabalho Relacionado\"),\n        ]),\n        _vm._v(\n          \"). No entanto, uma vez que os conjuntos de\\nvalidadores devem ser capazes de mudar, durante um longo período de tempo, os validadores originais podem\\ntornar-se não ligados e, portanto, seriam livres para criar uma nova cadeia a partir do bloco gênese,\\nnão incorrendo nenhum custo, visto que eles não tem depósitos trancados. Este ataque veio a ser conhecido\\ncomo Ataque de Longo Alcance (Long Range Attack - LRA), em contraste com um Ataque de Curto Alcance,\\nonde os validadores que estão atualmente ligados causam um fork e são, portanto, puníveis\\n(assumindo um algoritimo BFT de fork-responsável como o consenso Tendermint).\\nAtaques de longo alcance são muitas vezes pensados para serem um golpe crítico para o PoW.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Felizmente, o LRA pode ser atenuado da seguinte forma. Em primeiro lugar, para que um validador se\\ndesatar (assim recuperando seu depósito colateral e não mais ganhando taxas para participar no consenso),\\no depósito deve ser tornado intransferível por um período de tempo conhecido como o “unbonding period”\\n(período de desatamento), que pode ser na ordem de semanas ou meses. Em segundo lugar, para um cliente\\nleve ser seguro, a primeira vez que ele se conecta à rede, ele deve verificar um hash de bloqueio recente\\ncontra uma fonte confiável ou, preferencialmente, várias fontes. Esta condição é por vezes referida como\\n“subjetividade fraca”. Finalmente, para permanecer seguro, ele deve sincronizar com o mais recente\\nvalidador definido, pelo menos, tão frequentemente quanto a duração do período de desatamento.\\nIsso garante que o cliente leve saiba sobre as alterações no conjunto de validação definido antes de\\num validador não ter mais o seu capital ligado e, portanto, não mais em jogo, o que permitiria enganar\\no cliente, executando um ataque de longo alcance, criando novos blocos re-começando em uma altura\\na qual foi ligado (assumindo que tem controle de muitas das primeiras chaves privadas).\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Note que superar o LRA desta forma requer uma revisão do modelo de segurança original do PoW. No PoW,\\npresume-se que um cliente leve pode sincronizar com a altura atual do bloco gênese confiável a qualquer\\nmomento simplesmente processando o PoW em cada cabeçalho de bloco. Para superar o LRA, entretanto,\\nexigimos que um cliente leve entre em linha com alguma regularidade para rastrear mudanças no conjunto\\nde validadores e que, na primeira vez em que eles fiquem on-line, eles devem ser particularmente cuidadosos\\npara autenticar o que ouvem da rede contra fontes confiáveis . Naturalmente, este último requisito é\\nsemelhante ao do Bitcoin, onde o protocolo e o software também devem ser obtidos a partir de uma fonte confiável.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"O método acima para prevenir LRA é bem adequado para validadores e nós completos de uma blockchain alimentada\\npor Tendermint porque estes nós são destinados a permanecerem conectados à rede. O método também é adequado\\npara clientes leves que podem ser esperados para sincronizar com a rede com freqüência. No entanto, para\\nos clientes leves que não se espera ter acesso frequente à Internet ou à rede da blockchain, ainda pode\\nser utilizada outra solução para superar o LRA. Os detentores de tokens não validadores podem publicar\\nos seus tokens como colaterais com um período de não ligação muito longo (por exemplo, muito mais longo\\ndo que o período de não ligação para validadores) e servir clientes leves com um método secundário de\\natestar a validade dos blocos atuais e hashes de blocos passados. Embora esses tokens não contam para a\\nsegurança do consenso da blockchain, eles podem fornecer fortes garantias para clientes leves. Se a\\nconsulta histórica de hash de blocos fosse suportada no Ethereum, qualquer pessoa poderia vincular\\nseus tokens em um contrato inteligente projetado especialmente para isso e fornecer serviços de\\ncomprovação de pagamentos, efetivamente criando um mercado para a segurança contra LRA de cliente leve.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"superando-forks-e-ataques-de-censura\" } }, [\n        _vm._v(\"Superando Forks e Ataques de Censura\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Devido à definição de uma confimação de bloco, qualquer coalizão de poder de voto ⅓+ pode interromper a\\nblockchain ficando off-line ou não transmitir os seus votos. Tal coalizão também pode censurar transações\\nparticulares rejeitando blocos que incluem essas transações, embora isso resultaria em uma proporção\\nsignificativa de propostas de blocos a serem rejeitadas, o que iria retardar a taxa de blocos\\nconfirmados da blockchain, reduzindo sua utilidade e valor. A coalizão mal-intencionada também pode transmitir\\nvotos em um fio de modo a triturar os blocos confirmados da blockchain para quase parar, ou se envolver em\\nqualquer combinação desses ataques. Finalmente, isso pode fazer com que a cadeia de blocos “forke” (bifurque),\\npor dupla assinatura ou violação as regras de bloqueio.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Se um adversário globalmente ativo também estivesse envolvido, poderia dividir a rede de tal maneira que\\npossa parecer que o subconjunto errado de validadores era responsável pela desaceleração. Esta não é apenas\\numa limitação do Tendermint, mas sim uma limitação de todos os protocolos de consenso cuja\\nrede é potencialmente controlada por um adversário ativo.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Para estes tipos de ataques, um subconjunto de validadores deve coordenar através de meios externos\\npara assinar um proposta de reorganização que escolhe um fork (e qualquer prova disso) e o\\nsubconjunto inicial de validadores com suas assinaturas. Os validadores que assinam tal\\nproposta de reorganização deixam seu colateral em todos os outros forks. Os clientes\\ndevem verificar as assinaturas na proposta de reorganização, verificar qualquer\\nevidência e fazer um julgamento ou solicitar ao usuário final uma decisão. Por exemplo,\\numa carteira para celular um aplicativo que pode alertar o usuário com um aviso de segurança,\\nenquanto um refrigerador pode aceitar qualquer proposta de reorganização assinada por\\n+½ dos validadores originais por poder de voto.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Nenhum algoritmo não-sincrônico tolerante a falhas Bizantino pode chegar a um consenso quando ⅓+\\nde poder de voto for desonesto, mas um fork supõe que ⅓+ do poder de voto já foram desonestos por\\ndupla assinatura ou bloqueio de mudança sem justificativa. Portanto, assinar a proposta de\\nreorganização é um problema de coordenação que não pode ser resolvido por qualquer protocolo\\nnão-sincronico (isto é, automaticamente e sem fazer suposições sobre a confiabilidade da rede subjacente).\\nPor enquanto, deixamos o problema da coordenação da proposta de reorganização para a coordenação\\nhumana através do consenso social na mídia na internet. Os validadores devem ter cuidado para garantir\\nque não haja partições de rede remanescentes antes de assinar uma proposta de reorganização,\\npara evitar situações em que duas propostas de reorganização em conflito sejam assinadas.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Assumindo que o meio de coordenação é externo e o protocolo é robusto, resulta-se que os forks são\\numa preocupação menor do que os ataques de censura.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Além de forks e censura, que exigem ⅓+ poder de votação Bizantina, uma coalizão de +⅔ poder de\\nvoto pode ser pratica arbitrária, estado inválido. Esta é a característica de qualquer sistema\\nde consenso (BFT). Ao contrário da dupla assinatura, que cria forks com provas facilmente\\nverificáveis, a detecção de obrigatoriedade de um estado inválido requer que os pares não\\nvalidadores verifiquem blocos inteiros, o que implica que eles mantêm uma cópia local do estado\\ne executam cada transação, computando a raiz de estado de forma independente para eles mesmos.\\nUma vez detectado, a única maneira de lidar com essa falha é através do consenso social.\\nPor exemplo, em situações em que o Bitcoin falhou, seja por causa de bugs de software\\n(como em março de 2013), ou praticar um estado inválido devido ao comportamento Bizantino\\ndos mineradores (como em julho de 2015), a comunidade bem conectada de negócios, desenvolvedores,\\nmineradores e outras organizações estabeleceu um consenso social sobre quais ações manuais se\\nfaziam necessárias para curar a rede. Além disso, uma vez que se pode esperar que os validadores\\nde uma cadeia de blocos de Tendermint sejam identificáveis, o compromisso de um estado inválido\\npode até ser punido por lei ou por alguma jurisprudência externa, se desejado.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"especificacao-tmsp\" } }, [\n        _vm._v(\"Especificação TMSP\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"TMSP consiste em 3 tipos de mensagens primárias que são entregues do núcleo para o aplicativo.\\nO aplicativo responde com mensagens de resposta correspondentes.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"A mensagem \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"AppendTx\")]),\n        _vm._v(\n          \" é o cavalo de trabalho da aplicação. Cada transação na blockchain\\né entregue com esta mensagem. O aplicativo precisa validar cada transação recebida com a\\nmensagem AppendTx contra o estado atual, o protocolo de aplicativo e as credenciais\\ncriptográficas da transação. Uma transação validada precisa atualizar o estado do\\naplicativo - vinculando um valor a um armazenamento de valores chave ou atualizando o banco de dados UTXO.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"A mensagem \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"CheckTx\")]),\n        _vm._v(\n          \" é semelhante à AppendTx, mas é apenas para validar transações. O mempool do\\nTendermint BFT primeiro verifica a validade de uma transação com o CheckTx e apenas relata\\ntransações válidas para seus pares. Os aplicativos podem verificar um nonce incremental na transação\\ne retornar um erro em CheckTx se o nonce é antigo.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"A mensagem \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"Commit\")]),\n        _vm._v(\n          \" é usada para calcular uma obrigação criptográfica com o estado atual da aplicação,\\npara ser colocada no próximo cabeçalho do bloco. Isso tem algumas propriedades úteis. Inconsistências\\nna atualização desse estado agora aparecerão como forks do blockchain que captura uma classe inteira\\nde erros de programação. Isso também simplifica o desenvolvimento de clientes leves e seguros,\\njá que as provas de Merkle-hash podem ser provadas verificando o hash de blocos,\\ne o hash de blocos é assinado por um quórum de validadores (por poder de voto).\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Mensagens TMSP adicionais permitem que o aplicativo acompanhe e altere o conjunto\\nde validadores e que o aplicativo receba as informações do bloco, como a altura e os votos de confirmação.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Pedidos/respostas TMSP são simples mensagens Protobuf.\\nConfira o \"\n        ),\n        _c(\n          \"a\",\n          {\n            attrs: {\n              href: \"https://github.com/tendermint/tmsp/blob/master/types/types.proto\",\n            },\n          },\n          [_vm._v(\"arquivo do esquema\")]\n        ),\n        _vm._v(\".\"),\n      ]),\n      _c(\"h5\", { attrs: { id: \"appendtx\" } }, [_vm._v(\"AppendTx\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Arguments\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Data ([]byte)\")]),\n              _vm._v(\": Os bytes de transação solicitada\"),\n            ]),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Returns\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Code (uint32)\")]),\n              _vm._v(\": Código de resposta\"),\n            ]),\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Data ([]byte)\")]),\n              _vm._v(\": Bytes de resultado, se houver\"),\n            ]),\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Log (string)\")]),\n              _vm._v(\": Debug ou mensagem de erro\"),\n            ]),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Usage\")]),\n          _vm._v(\":\"),\n          _c(\"br\"),\n          _vm._v(\n            \"\\nAcrescentar e executar uma transação. Se a transação for válida,\\nCodeType.OK\"\n          ),\n        ]),\n      ]),\n      _c(\"h5\", { attrs: { id: \"checktx\" } }, [_vm._v(\"CheckTx\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Arguments\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Data ([]byte)\")]),\n              _vm._v(\": Os bytes de transação solicitados\"),\n            ]),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Returns\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Code (uint32)\")]),\n              _vm._v(\": Código de resposta\"),\n            ]),\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Data ([]byte)\")]),\n              _vm._v(\": Bytes de resultado, se houver\"),\n            ]),\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Log (string)\")]),\n              _vm._v(\": Debug ou mensagem de erro\"),\n            ]),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Usage\")]),\n          _vm._v(\":\"),\n          _c(\"br\"),\n          _vm._v(\n            \"\\nValidar uma transação. Esta mensagem não deve mutar o estado.\\nAs transações são primeiro executadas através do CheckTx antes da transmissão para os pares na camada mempool.\\nVocê pode fazer o CheckTx semi-stateful e limpar o estado após \"\n          ),\n          _c(\"code\", { pre: true }, [_vm._v(\"Commit\")]),\n          _vm._v(\" ou\\n\"),\n          _c(\"code\", { pre: true }, [_vm._v(\"BeginBlock\")]),\n          _vm._v(\n            \",\\npara permitir sequências dependentes de transações no mesmo bloco.\"\n          ),\n        ]),\n      ]),\n      _c(\"h5\", { attrs: { id: \"commit\" } }, [_vm._v(\"Commit\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Returns\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Data ([]byte)\")]),\n              _vm._v(\": O hash Merkle raiz\"),\n            ]),\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Log (string)\")]),\n              _vm._v(\": Debug ou erro de mensagem\"),\n            ]),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Usage\")]),\n          _vm._v(\":\"),\n          _c(\"br\"),\n          _vm._v(\"\\nRetorna um hash Merkle raiz do estado da aplicação.\"),\n        ]),\n      ]),\n      _c(\"h5\", { attrs: { id: \"query\" } }, [_vm._v(\"Query\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Arguments\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Data ([]byte)\")]),\n              _vm._v(\": Os bytes de solicitação consultada\"),\n            ]),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Returns\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Code (uint32)\")]),\n              _vm._v(\": Código de resposta\"),\n            ]),\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Data ([]byte)\")]),\n              _vm._v(\": Os bytes de resposta consultada\"),\n            ]),\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Log (string)\")]),\n              _vm._v(\": Debug ou erro de mensagem\"),\n            ]),\n          ]),\n        ]),\n      ]),\n      _c(\"h5\", { attrs: { id: \"flush\" } }, [_vm._v(\"Flush\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Usage\")]),\n          _vm._v(\":\"),\n          _c(\"br\"),\n          _vm._v(\"\\nLimpar a fila de resposta. Aplicações que implementam \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"types.Application\")]),\n          _vm._v(\n            \"\\nnão precisa implementar esta mensagem - é tratada pelo projeto.\"\n          ),\n        ]),\n      ]),\n      _c(\"h5\", { attrs: { id: \"info\" } }, [_vm._v(\"Info\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Returns\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Data ([]byte)\")]),\n              _vm._v(\": Os bytes de informação\"),\n            ]),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Usage\")]),\n          _vm._v(\":\"),\n          _c(\"br\"),\n          _vm._v(\n            \"\\nRetorna informações sobre o estado da aplicação. Aplicação específicão.\"\n          ),\n        ]),\n      ]),\n      _c(\"h5\", { attrs: { id: \"setoption\" } }, [_vm._v(\"SetOption\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Arguments\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Key (string)\")]),\n              _vm._v(\": Chave para definir\"),\n            ]),\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Value (string)\")]),\n              _vm._v(\": Valor a definir para a chave\"),\n            ]),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Returns\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Log (string)\")]),\n              _vm._v(\": Debug ou mensagem de erro\"),\n            ]),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Usage\")]),\n          _vm._v(\":\"),\n          _c(\"br\"),\n          _vm._v(\n            \"\\nDefine as opções do aplicativo. Exemplo Key=“mode”, Value=“mempool” para uma conexão mempool\\n, ou Key=“mode”, Value=“consensus” para uma conexão de consenso.\\nOutras opções são específicas da aplicação.\"\n          ),\n        ]),\n      ]),\n      _c(\"h5\", { attrs: { id: \"initchain\" } }, [_vm._v(\"InitChain\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Arguments\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Validators ([]Validator)\")]),\n              _vm._v(\": validadores de genesis iniciais\"),\n            ]),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Usage\")]),\n          _vm._v(\":\"),\n          _c(\"br\"),\n          _vm._v(\"\\nChamado uma vez na genesis\"),\n        ]),\n      ]),\n      _c(\"h5\", { attrs: { id: \"beginblock\" } }, [_vm._v(\"BeginBlock\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Arguments\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Height (uint64)\")]),\n              _vm._v(\": A altura do bloco que está começando\"),\n            ]),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Usage\")]),\n          _vm._v(\":\"),\n          _c(\"br\"),\n          _vm._v(\n            \"\\nSinaliza o início de um novo bloco. Chamado antes de qualquer AppendTxs.\"\n          ),\n        ]),\n      ]),\n      _c(\"h5\", { attrs: { id: \"endblock\" } }, [_vm._v(\"EndBlock\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Arguments\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Height (uint64)\")]),\n              _vm._v(\": A altura do bloco que terminou\"),\n            ]),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Returns\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Validators ([]Validator)\")]),\n              _vm._v(\n                \": Mudança de validadores com novos poderes de voto (0\\npara remover)\"\n              ),\n            ]),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"strong\", [_vm._v(\"Usage\")]),\n          _vm._v(\":\"),\n          _c(\"br\"),\n          _vm._v(\n            \"\\nSinaliza o fim de um bloco. Chamado antes de cada Commit após todas as\\ntransações\"\n          ),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Veja \"),\n        _c(\n          \"a\",\n          {\n            attrs: { href: \"https://github.com/tendermint/tmsp#message-types\" },\n          },\n          [_vm._v(\"o repositório TMSP\")]\n        ),\n        _vm._v(\" para mais detalhes.\"),\n      ]),\n      _c(\"h3\", { attrs: { id: \"reconhecimento-de-entrega-de-pacotes-ibc\" } }, [\n        _vm._v(\"Reconhecimento de entrega de pacotes IBC\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Há várias razões pelas quais um remetente pode querer o reconhecimento da entrega de um pacote\\npela cadeia de recebimento. Por exemplo, o remetente pode não saber o status da cadeia de\\ndestino, se for esperado que esteja com defeito. Ou, o remetente pode querer impor um tempo\\nlimite no pacote (com o campo \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"MaxHeight\")]),\n        _vm._v(\n          \"), enquanto qualquer cadeia de destino pode sofrer\\nde um ataque de negação de serviço com um aumento repentino no número de pacotes de entrada.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Nesses casos, o remetente pode exigir confirmação de entrega configurando o status\\ndo pacote inicial como \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"AckPending\")]),\n        _vm._v(\n          \". Em seguida, é a responsabilidade da\\ncadeia receptora confirmar a entrega, incluindo uma abreviada \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacket\")]),\n        _vm._v(\" no app Merkle hash.\"),\n      ]),\n      _c(\"p\", [\n        _c(\"img\", {\n          attrs: {\n            src: \"https://raw.githubusercontent.com/gnuclear/atom-whitepaper/master/msc/ibc_with_ack.png\",\n            alt: \"Figura da Zone1, Zone2, e Hub IBC comreconhecimento\",\n          },\n        }),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Primeiro, um \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCBlockCommit\")]),\n        _vm._v(\" e\"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketTx\")]),\n        _vm._v(\" são postados no “Hub” que prova\\na existência de um \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacket\")]),\n        _vm._v(\" na “Zone1”. Digamos que \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketTx\")]),\n        _vm._v(\" tem o seguinte valor:\"),\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"FromChainID\")]),\n          _vm._v(\": “Zone1”\"),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"FromBlockHeight\")]),\n          _vm._v(\": 100 (say)\"),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"Packet\")]),\n          _vm._v(\": an \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"IBCPacket\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Header\")]),\n              _vm._v(\": an \"),\n              _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketHeader\")]),\n              _vm._v(\":\\n\"),\n              _c(\"ul\", [\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"SrcChainID\")]),\n                  _vm._v(\": “Zone1”\"),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"DstChainID\")]),\n                  _vm._v(\": “Zone2”\"),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"Number\")]),\n                  _vm._v(\": 200 (say)\"),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"Status\")]),\n                  _vm._v(\": \"),\n                  _c(\"code\", { pre: true }, [_vm._v(\"AckPending\")]),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"Type\")]),\n                  _vm._v(\": “moeda”\"),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"MaxHeight\")]),\n                  _vm._v(\n                    \": 350 (Dizer que “Hub” está atualmente na altura 300)\"\n                  ),\n                ]),\n              ]),\n            ]),\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Payload\")]),\n              _vm._v(\": <Os bytes de uma carga paga de “moeda”>\"),\n            ]),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Em seguida, um \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCBlockCommit\")]),\n        _vm._v(\" e \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketTx\")]),\n        _vm._v(\" são publicados na “Zone2” que comprova\\na existência de um \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacket\")]),\n        _vm._v(\" em “Hub”. Digamos que \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketTx\")]),\n        _vm._v(\" tem o seguinte valor:\"),\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"FromChainID\")]),\n          _vm._v(\": “Hub”\"),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"FromBlockHeight\")]),\n          _vm._v(\": 300\"),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"Packet\")]),\n          _vm._v(\": an \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"IBCPacket\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Header\")]),\n              _vm._v(\": an \"),\n              _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketHeader\")]),\n              _vm._v(\":\\n\"),\n              _c(\"ul\", [\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"SrcChainID\")]),\n                  _vm._v(\": “Zone1”\"),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"DstChainID\")]),\n                  _vm._v(\": “Zone2”\"),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"Number\")]),\n                  _vm._v(\": 200\"),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"Status\")]),\n                  _vm._v(\": \"),\n                  _c(\"code\", { pre: true }, [_vm._v(\"AckPending\")]),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"Type\")]),\n                  _vm._v(\": “moeda”\"),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"MaxHeight\")]),\n                  _vm._v(\": 350\"),\n                ]),\n              ]),\n            ]),\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Payload\")]),\n              _vm._v(\": <Os mesmos bytes de uma carga paga de “moeda”>\"),\n            ]),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Em seguida, “Zone2” deve incluir em seu app-hash um pacote abreviado que mostra o novo\\nstatus de \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"AckSent\")]),\n        _vm._v(\". Um \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCBlockCommit\")]),\n        _vm._v(\" e \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketTx\")]),\n        _vm._v(\n          \" são colocados de volta no “Hub”\\nque comprova a existência de um \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacket\")]),\n        _vm._v(\" abreviado na “Zone2”. Digamos que \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketTx\")]),\n        _vm._v(\" tem o seguinte valor:\"),\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"FromChainID\")]),\n          _vm._v(\": “Zone2”\"),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"FromBlockHeight\")]),\n          _vm._v(\": 400 (say)\"),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"Packet\")]),\n          _vm._v(\": an \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"IBCPacket\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Header\")]),\n              _vm._v(\": an \"),\n              _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketHeader\")]),\n              _vm._v(\":\\n\"),\n              _c(\"ul\", [\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"SrcChainID\")]),\n                  _vm._v(\": “Zone1”\"),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"DstChainID\")]),\n                  _vm._v(\": “Zone2”\"),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"Number\")]),\n                  _vm._v(\": 200\"),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"Status\")]),\n                  _vm._v(\": \"),\n                  _c(\"code\", { pre: true }, [_vm._v(\"AckSent\")]),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"Type\")]),\n                  _vm._v(\": “moeda”\"),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"MaxHeight\")]),\n                  _vm._v(\": 350\"),\n                ]),\n              ]),\n            ]),\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"PayloadHash\")]),\n              _vm._v(\": <Os bytes de hash da mesma carga paga de “moeda”>\"),\n            ]),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Finalmente, “Hub” deve atualizar o status do pacote de \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"AckPending\")]),\n        _vm._v(\" para\"),\n        _c(\"code\", { pre: true }, [_vm._v(\"AckReceived\")]),\n        _vm._v(\n          \".\\nA evidência desse novo status finalizado deve voltar a “Zone2”. Digamos que \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketTx\")]),\n        _vm._v(\" tem o seguinte valor:\"),\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"FromChainID\")]),\n          _vm._v(\": “Hub”\"),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"FromBlockHeight\")]),\n          _vm._v(\": 301\"),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"Packet\")]),\n          _vm._v(\": an \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"IBCPacket\")]),\n          _vm._v(\":\\n\"),\n          _c(\"ul\", [\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"Header\")]),\n              _vm._v(\": an \"),\n              _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketHeader\")]),\n              _vm._v(\":\\n\"),\n              _c(\"ul\", [\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"SrcChainID\")]),\n                  _vm._v(\": “Zone1”\"),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"DstChainID\")]),\n                  _vm._v(\": “Zone2”\"),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"Number\")]),\n                  _vm._v(\": 200\"),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"Status\")]),\n                  _vm._v(\": \"),\n                  _c(\"code\", { pre: true }, [_vm._v(\"AckReceived\")]),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"Type\")]),\n                  _vm._v(\": “moeda”\"),\n                ]),\n                _c(\"li\", [\n                  _c(\"code\", { pre: true }, [_vm._v(\"MaxHeight\")]),\n                  _vm._v(\": 350\"),\n                ]),\n              ]),\n            ]),\n            _c(\"li\", [\n              _c(\"code\", { pre: true }, [_vm._v(\"PayloadHash\")]),\n              _vm._v(\": <Os bytes de hash da mesma carga paga de “moeda”>\"),\n            ]),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Enquanto isso, “Zone1” pode assumir de maneira otimista a entrega bem-sucedida de um pacote\\nde “moeda”, a menos que provas em contrário sejam comprovadas em “Hub”. No exemplo acima,\\nse “Hub” não tivesse recebido um status \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"AckSent\")]),\n        _vm._v(\n          \" de “Zone2” pelo bloco 350, ele teria\\ndefinido o status automaticamente para \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"Timeout\")]),\n        _vm._v(\n          \". Essa evidência de um tempo limite pode\\nser postada novamente na “Zone1”, e quaisquer tokens podem ser retornados.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _c(\"img\", {\n          attrs: {\n            src: \"https://raw.githubusercontent.com/gnuclear/atom-whitepaper/master/msc/ibc_with_ack_timeout.png\",\n            alt: \"Figura da Zone1, Zone2, e Hub IBC com reconhecimento etimeout\",\n          },\n        }),\n      ]),\n      _c(\"h3\", { attrs: { id: \"arvore-merkle-e-especificacao-de-prova\" } }, [\n        _vm._v(\"Árvore Merkle e Especificação de Prova\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Existem dois tipos de árvores Merkle suportadas no ecossistema Tendermint / Cosmos: A Árvore Simples e a Árvore IAVL+.\"\n        ),\n      ]),\n      _c(\"h4\", { attrs: { id: \"arvore-simples\" } }, [_vm._v(\"Árvore Simples\")]),\n      _c(\"p\", [\n        _vm._v(\n          \"A Árvore Simples é uma árvore Merkle para uma lista estática de elementos. Se o número de\\nitens não for um poder de dois, algumas folhas estarão em níveis diferentes. Árvore Simples\\ntenta manter ambos os lados da árvore da mesma altura, mas a esquerda pode ter um maior.\\nEsta árvore Merkle é usada para Merkle-lizar as transações de um bloco, e os elementos de\\nnível superior da raiz do estado do aplicativo.\"\n        ),\n      ]),\n      _c(\"pre\", { pre: true }, [\n        _c(\"code\", { pre: true, attrs: { \"v-pre\": \"\" } }, [\n          _vm._v(\n            \"                *\\n               / \\\\\\n             /     \\\\\\n           /         \\\\\\n         /             \\\\\\n        *               *\\n       / \\\\             / \\\\\\n      /   \\\\           /   \\\\\\n     /     \\\\         /     \\\\\\n    *       *       *       h6\\n   / \\\\     / \\\\     / \\\\\\n  h0  h1  h2  h3  h4  h5\\n\\n  Uma ÁrvoreSimples com sete elementos\\n\"\n          ),\n        ]),\n      ]),\n      _c(\"h4\", { attrs: { id: \"arvore-iavl\" } }, [_vm._v(\"Árvore IAVL+\")]),\n      _c(\"p\", [\n        _vm._v(\n          \"O objetivo da estrutura de dados IAVL+ é fornecer armazenamento persistente para pares de valores-chave\\nno estado do aplicativo, de modo que um hash determinista de raiz Merkle possa ser calculado\\neficientemente. A árvore é balanceada usando uma variante do \"\n        ),\n        _c(\"a\", { attrs: { href: \"http://en.wikipedia.org/wiki/AVL_tree\" } }, [\n          _vm._v(\"algoritmo AVL\"),\n        ]),\n        _vm._v(\", e todas as operações são O(log(n)).\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Em uma árvore AVL, as alturas das duas subárvores filhas de qualquer nó diferem por no máximo um.\\nSempre que esta condição for violada após uma atualização, a árvore é rebalanceada criando O(log(n))\\nnovos nós que apontam para nós não modificados da árvore antiga. No algoritmo AVL original, os nós\\ninternos também podem conter pares de valores-chave. O algoritmo AVL + (observe o sinal de adição)\\nmodifica o algoritmo AVL para manter todos os valores em folha de nós, enquanto\\nusando apenas nós de ramo para armazenar chaves. Isso simplifica o algoritmo, mantendo a trilha hash merkle curta.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"A Árvore AVL + é análoga à Ethereum \"),\n        _c(\n          \"a\",\n          { attrs: { href: \"http://en.wikipedia.org/wiki/Radix_tree\" } },\n          [_vm._v(\"Patricia tries\")]\n        ),\n        _vm._v(\n          \".\\nHá compensações. Chaves não precisam ser hasheadas antes da inserção em árvores IAVL+, portanto,\\nisso fornece iteração mais rápida ordenada no espaço-chave que pode beneficiar algumas aplicações.\\nA lógica é mais simples de implementar, requerendo apenas dois tipos de nós - nós internos e nós de folhas.\\nA prova de Merkle é em média mais curta, sendo uma árvore binária equilibrada. Por outro lado,\\na raiz Merkle de uma árvore IAVL+ depende da ordem das atualizações.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Iremos apoiar outras árvores Merkle eficientes, como Patricia Trie, da Ethereum, quando a variante binária estiver disponível.\"\n        ),\n      ]),\n      _c(\"h3\", { attrs: { id: \"tipos-de-transacao\" } }, [\n        _vm._v(\"Tipos de Transação\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Na implementação canônica, as transações são transmitidas para o aplicativo Cosmos hub através da interface TMSP.\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"O Cosmos Hub aceitará uma série de tipos de transações primárias, incluindo \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"SendTx\")]),\n        _vm._v(\",\\n\"),\n        _c(\"code\", { pre: true }, [_vm._v(\"BondTx\")]),\n        _vm._v(\", \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"UnbondTx\")]),\n        _vm._v(\", \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"ReportHackTx\")]),\n        _vm._v(\", \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"SlashTx\")]),\n        _vm._v(\", \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"BurnAtomTx\")]),\n        _vm._v(\", \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"ProposalCreateTx\")]),\n        _vm._v(\" e \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"ProposalVoteTx\")]),\n        _vm._v(\n          \",\\nque são relativamente auto-explicativas e será documentado em uma futura revisão deste artigo.\\nAqui documentamos os dois principais tipos de transação para IBC: \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCBlockCommitTx\")]),\n        _vm._v(\" e \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketTx\")]),\n        _vm._v(\".\"),\n      ]),\n      _c(\"h4\", { attrs: { id: \"ibcblockcommittx\" } }, [\n        _vm._v(\"IBCBlockCommitTx\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Uma transação \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCBlockCommitTx\")]),\n        _vm._v(\" é composta de:\"),\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"ChainID (string)\")]),\n          _vm._v(\": O ID da blockchain\"),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"BlockHash ([]byte)\")]),\n          _vm._v(\n            \": Os bytes de hash de bloco, a raiz Merkle que inclui o app-hash\"\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [\n            _vm._v(\"BlockPartsHeader (PartSetHeader)\"),\n          ]),\n          _vm._v(\n            \": Os bytes de cabeçalho do conjunto de blocos,\\napenas necessários para verificar assinaturas de voto\"\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"BlockHeight (int)\")]),\n          _vm._v(\": A altura do commit\"),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"BlockRound (int)\")]),\n          _vm._v(\": A rodada do commit\"),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"Commit ([]Vote)\")]),\n          _vm._v(\": O +⅔ Tendermint \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"Precommit\")]),\n          _vm._v(\" de votos que compõem um bloco\"),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"ValidatorsHash ([]byte)\")]),\n          _vm._v(\n            \": O hash da raiz da árvore-Merkle do novo conjunto de validadores\"\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [\n            _vm._v(\"ValidatorsHashProof (SimpleProof)\"),\n          ]),\n          _vm._v(\": Uma ÁrvoreSimples da prova-Merkle para provar o\\n\"),\n          _c(\"code\", { pre: true }, [_vm._v(\"ValidatorsHash\")]),\n          _vm._v(\" contra o \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"BlockHash\")]),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"AppHash ([]byte)\")]),\n          _vm._v(\n            \": Um hash da raiz da árvore-Merkle da Árvore IAVL do estado de aplicação\"\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"AppHashProof (SimpleProof)\")]),\n          _vm._v(\": Uma ÁrvoreSimples da prova-Merkle para provar o\\n\"),\n          _c(\"code\", { pre: true }, [_vm._v(\"AppHash\")]),\n          _vm._v(\" contra o \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"BlockHash\")]),\n        ]),\n      ]),\n      _c(\"h4\", { attrs: { id: \"ibcpackettx\" } }, [_vm._v(\"IBCPacketTx\")]),\n      _c(\"p\", [\n        _vm._v(\"Um \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacket\")]),\n        _vm._v(\" é composto de:\"),\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"Header (IBCPacketHeader)\")]),\n          _vm._v(\": O cabeçalho do pacote\"),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"Payload ([]byte)\")]),\n          _vm._v(\": Os bytes da carga paga do pacote. \"),\n          _c(\"em\", [_vm._v(\"Optional\")]),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"PayloadHash ([]byte)\")]),\n          _vm._v(\": O hash para os bytes do pacote. \"),\n          _c(\"em\", [_vm._v(\"Optional\")]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Qualquer um dos \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"Payload\")]),\n        _vm._v(\" ou \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"PayloadHash\")]),\n        _vm._v(\" deve estar presente. O hash de um \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacket\")]),\n        _vm._v(\"\\né uma raiz Merkle simples dos dois itens, \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"Header\")]),\n        _vm._v(\" e \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"Payload\")]),\n        _vm._v(\". Um \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacket\")]),\n        _vm._v(\" sem a carga completa\\né chamado de \"),\n        _c(\"em\", [_vm._v(\"abbreviated packet\")]),\n        _vm._v(\".\"),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Um \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketHeader\")]),\n        _vm._v(\" é composto de:\"),\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"SrcChainID (string)\")]),\n          _vm._v(\": O ID da blockchain fonte\"),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"DstChainID (string)\")]),\n          _vm._v(\": O ID da blockchain destino\"),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"Number (int)\")]),\n          _vm._v(\": Um número exclusivo para todos os pacotes\"),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"Status (enum)\")]),\n          _vm._v(\": Pode ser um \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"AckPending\")]),\n          _vm._v(\", \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"AckSent\")]),\n          _vm._v(\", \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"AckReceived\")]),\n          _vm._v(\",\\n\"),\n          _c(\"code\", { pre: true }, [_vm._v(\"NoAck\")]),\n          _vm._v(\", ou \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"Timeout\")]),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"Type (string)\")]),\n          _vm._v(\n            \": Os tipos são dependentes da aplicação. Cosmos reserva-se ao tipo de pacote “moeda”\"\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"MaxHeight (int)\")]),\n          _vm._v(\": Se status não for \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"NoAckWanted\")]),\n          _vm._v(\" ou \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"AckReceived\")]),\n          _vm._v(\" por essa altura, o status se tornará \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"Timeout\")]),\n          _vm._v(\". \"),\n          _c(\"em\", [_vm._v(\"Opcional\")]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"Uma transação \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketTx\")]),\n        _vm._v(\" é composta de:\"),\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"FromChainID (string)\")]),\n          _vm._v(\n            \": O ID da blockchain que está fornecendo este pacote; Não necessariamente a fonte\"\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"FromBlockHeight (int)\")]),\n          _vm._v(\n            \": A altura da blockchain na qual o seguinte pacote é incluído (Merkle-izado) no hash da blockchain de origem\"\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"Packet (IBCPacket)\")]),\n          _vm._v(\": Um pacote de dados, cujo estado pode ser um\\n\"),\n          _c(\"code\", { pre: true }, [_vm._v(\"AckPending\")]),\n          _vm._v(\", \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"AckSent\")]),\n          _vm._v(\", \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"AckReceived\")]),\n          _vm._v(\", \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"NoAck\")]),\n          _vm._v(\", ou \"),\n          _c(\"code\", { pre: true }, [_vm._v(\"Timeout\")]),\n        ]),\n        _c(\"li\", [\n          _c(\"code\", { pre: true }, [_vm._v(\"PacketProof (IAVLProof)\")]),\n          _vm._v(\n            \": Uma prova-Merkle da Árvore IAVL para para provar o hash do pacote contra o `AppHash’ da cadeia de origem em determinada altura\"\n          ),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"A seqüência para enviar um pacote da “Zone1” para a “Zone2” através do “Hub” é mostrada em {Figure X}.\\nPrimeiro, um \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketTx\")]),\n        _vm._v(\n          \" prova ao “Hub” que o pacote está incluído no estado da aplicação de “Zone1”.\\nEm seguida, outro \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacketTx\")]),\n        _vm._v(\n          \" prova a “Zone2” que o pacote está incluído no estado da aplicação “Hub”.\\nDurante esse procedimento, os campos \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacket\")]),\n        _vm._v(\" são idênticos: o \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"SrcChainID\")]),\n        _vm._v(\" é sempre “Zone1”,\\ne o \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"DstChainID\")]),\n        _vm._v(' é sempre\" Zone2 \".'),\n      ]),\n      _c(\"p\", [\n        _vm._v(\"O \"),\n        _c(\"code\", { pre: true }, [_vm._v(\"PacketProof\")]),\n        _vm._v(\n          \" deve ter o caminho correto da prova-Merkle, da seguinte maneira:\"\n        ),\n      ]),\n      _c(\"pre\", { pre: true }, [\n        _c(\"code\", { pre: true, attrs: { \"v-pre\": \"\" } }, [\n          _vm._v(\"IBC/<SrcChainID>/<DstChainID>/<Number>\\n\"),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"Quando “Zone1” quer enviar um pacote para “Zone2” através do “Hub”, os dados de \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"IBCPacket\")]),\n        _vm._v(\n          \"\\nsão idênticos se o pacote é Merkle-izado em “Zone1”, no “Hub” ou “Zone2”. O único campo mutável\\né \"\n        ),\n        _c(\"code\", { pre: true }, [_vm._v(\"Status\")]),\n        _vm._v(\" para acompanhar a entrega, conforme mostrado abaixo.\"),\n      ]),\n      _c(\"h2\", { attrs: { id: \"agradecimentos\" } }, [_vm._v(\"Agradecimentos\")]),\n      _c(\"p\", [\n        _vm._v(\n          \"Agradecemos aos nossos amigos e colegas por sua ajuda na conceituação, revisão e apoio no nosso trabalho com Tendermint e Cosmos.\"\n        ),\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"a\", { attrs: { href: \"https://github.com/zmanian\" } }, [\n            _vm._v(\"Zaki Manian\"),\n          ]),\n          _vm._v(\" da\\n\"),\n          _c(\"a\", { attrs: { href: \"https://www.skuchain.com/\" } }, [\n            _vm._v(\"SkuChain\"),\n          ]),\n          _vm._v(\n            \" forneceu muita ajuda na formatação e redacção, especialmente sob a seção TMSP\"\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\"a\", { attrs: { href: \"https://github.com/jtremback\" } }, [\n            _vm._v(\"Jehan Tremback\"),\n          ]),\n          _vm._v(\n            \" da Althea and Dustin Byington\\npor ajudar com iterações iniciais\"\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\"a\", { attrs: { href: \"http://soc1024.com/\" } }, [\n            _vm._v(\"Andrew Miller\"),\n          ]),\n          _vm._v(\" da \"),\n          _c(\"a\", { attrs: { href: \"https://eprint.iacr.org/2016/199\" } }, [\n            _vm._v(\"Honey\\nBadger\"),\n          ]),\n          _vm._v(\" pelo feedback sobre consenso\"),\n        ]),\n        _c(\"li\", [\n          _c(\"a\", { attrs: { href: \"https://fixingtao.com/\" } }, [\n            _vm._v(\"Greg Slepak\"),\n          ]),\n          _vm._v(\" pelo feedback sobre consenso e redação\"),\n        ]),\n        _c(\"li\", [\n          _vm._v(\"Também agradecemos ao \"),\n          _c(\"a\", { attrs: { href: \"https://github.com/gleim\" } }, [\n            _vm._v(\"Bill Gleim\"),\n          ]),\n          _vm._v(\" e \"),\n          _c(\"a\", { attrs: { href: \"http://www.seunghwanhan.com\" } }, [\n            _vm._v(\"Seunghwan\\nHan\"),\n          ]),\n          _vm._v(\" por várias contribuições.\"),\n        ]),\n        _c(\"li\", [\n          _c(\"a\", { attrs: { href: \"https://github.com/ShooterXD\" } }, [\n            _vm._v(\"Pedro Augusto\"),\n          ]),\n          _vm._v(\" pela tradução para\\nPortuguês\"),\n        ]),\n      ]),\n      _c(\"h2\", { attrs: { id: \"citacoes\" } }, [_vm._v(\"Citações\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"a\", { attrs: { href: \"https://bitcoin.org/bitcoin.pdf\" } }, [\n            _vm._v(\"1\"),\n          ]),\n          _vm._v(\" Bitcoin: \"),\n          _c(\"a\", { attrs: { href: \"https://bitcoin.org/bitcoin.pdf\" } }, [\n            _vm._v(\"https://bitcoin.org/bitcoin.pdf\"),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"a\", { attrs: { href: \"http://zerocash-project.org/paper\" } }, [\n            _vm._v(\"2\"),\n          ]),\n          _vm._v(\" ZeroCash: \"),\n          _c(\"a\", { attrs: { href: \"http://zerocash-project.org/paper\" } }, [\n            _vm._v(\"http://zerocash-project.org/paper\"),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://github.com/ethereum/wiki/wiki/White-Paper\",\n              },\n            },\n            [_vm._v(\"3\")]\n          ),\n          _vm._v(\" Ethereum: \"),\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://github.com/ethereum/wiki/wiki/White-Paper\",\n              },\n            },\n            [_vm._v(\"https://github.com/ethereum/wiki/wiki/White-Paper\")]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://download.slock.it/public/DAO/WhitePaper.pdf\",\n              },\n            },\n            [_vm._v(\"4\")]\n          ),\n          _vm._v(\" TheDAO: \"),\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://download.slock.it/public/DAO/WhitePaper.pdf\",\n              },\n            },\n            [_vm._v(\"https://download.slock.it/public/DAO/WhitePaper.pdf\")]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki\",\n              },\n            },\n            [_vm._v(\"5\")]\n          ),\n          _vm._v(\" Segregated Witness: \"),\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki\",\n              },\n            },\n            [\n              _vm._v(\n                \"https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki\"\n              ),\n            ]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            { attrs: { href: \"https://arxiv.org/pdf/1510.02037v2.pdf\" } },\n            [_vm._v(\"6\")]\n          ),\n          _vm._v(\" BitcoinNG: \"),\n          _c(\n            \"a\",\n            { attrs: { href: \"https://arxiv.org/pdf/1510.02037v2.pdf\" } },\n            [_vm._v(\"https://arxiv.org/pdf/1510.02037v2.pdf\")]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://lightning.network/lightning-network-paper-DRAFT-0.5.pdf\",\n              },\n            },\n            [_vm._v(\"7\")]\n          ),\n          _vm._v(\" Lightning Network: \"),\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://lightning.network/lightning-network-paper-DRAFT-0.5.pdf\",\n              },\n            },\n            [\n              _vm._v(\n                \"https://lightning.network/lightning-network-paper-DRAFT-0.5.pdf\"\n              ),\n            ]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            {\n              attrs: { href: \"https://github.com/tendermint/tendermint/wiki\" },\n            },\n            [_vm._v(\"8\")]\n          ),\n          _vm._v(\" Tendermint: \"),\n          _c(\n            \"a\",\n            {\n              attrs: { href: \"https://github.com/tendermint/tendermint/wiki\" },\n            },\n            [_vm._v(\"https://github.com/tendermint/tendermint/wiki\")]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf\",\n              },\n            },\n            [_vm._v(\"9\")]\n          ),\n          _vm._v(\" FLP Impossibility: \"),\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf\",\n              },\n            },\n            [_vm._v(\"https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf\")]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://blog.ethereum.org/2014/01/15/slasher-a-punitive-proof-of-stake-algorithm/\",\n              },\n            },\n            [_vm._v(\"10\")]\n          ),\n          _vm._v(\" Slasher: \"),\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://blog.ethereum.org/2014/01/15/slasher-a-punitive-proof-of-stake-algorithm/\",\n              },\n            },\n            [\n              _vm._v(\n                \"https://blog.ethereum.org/2014/01/15/slasher-a-punitive-proof-of-stake-algorithm/\"\n              ),\n            ]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            { attrs: { href: \"http://pmg.csail.mit.edu/papers/osdi99.pdf\" } },\n            [_vm._v(\"11\")]\n          ),\n          _vm._v(\" PBFT: \"),\n          _c(\n            \"a\",\n            { attrs: { href: \"http://pmg.csail.mit.edu/papers/osdi99.pdf\" } },\n            [_vm._v(\"http://pmg.csail.mit.edu/papers/osdi99.pdf\")]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://bitshares.org/technology/delegated-proof-of-stake-consensus/\",\n              },\n            },\n            [_vm._v(\"12\")]\n          ),\n          _vm._v(\" BitShares: \"),\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://bitshares.org/technology/delegated-proof-of-stake-consensus/\",\n              },\n            },\n            [\n              _vm._v(\n                \"https://bitshares.org/technology/delegated-proof-of-stake-consensus/\"\n              ),\n            ]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://www.stellar.org/papers/stellar-consensus-protocol.pdf\",\n              },\n            },\n            [_vm._v(\"13\")]\n          ),\n          _vm._v(\" Stellar: \"),\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://www.stellar.org/papers/stellar-consensus-protocol.pdf\",\n              },\n            },\n            [\n              _vm._v(\n                \"https://www.stellar.org/papers/stellar-consensus-protocol.pdf\"\n              ),\n            ]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://interledger.org/rfcs/0001-interledger-architecture/\",\n              },\n            },\n            [_vm._v(\"14\")]\n          ),\n          _vm._v(\" Interledger: \"),\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://interledger.org/rfcs/0001-interledger-architecture/\",\n              },\n            },\n            [\n              _vm._v(\n                \"https://interledger.org/rfcs/0001-interledger-architecture/\"\n              ),\n            ]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            { attrs: { href: \"https://blockstream.com/sidechains.pdf\" } },\n            [_vm._v(\"15\")]\n          ),\n          _vm._v(\" Sidechains: \"),\n          _c(\n            \"a\",\n            { attrs: { href: \"https://blockstream.com/sidechains.pdf\" } },\n            [_vm._v(\"https://blockstream.com/sidechains.pdf\")]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://blog.ethereum.org/2015/08/01/introducing-casper-friendly-ghost/\",\n              },\n            },\n            [_vm._v(\"16\")]\n          ),\n          _vm._v(\" Casper: \"),\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://blog.ethereum.org/2015/08/01/introducing-casper-friendly-ghost/\",\n              },\n            },\n            [\n              _vm._v(\n                \"https://blog.ethereum.org/2015/08/01/introducing-casper-friendly-ghost/\"\n              ),\n            ]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\"a\", { attrs: { href: \"https://github.com/tendermint/tmsp\" } }, [\n            _vm._v(\"17\"),\n          ]),\n          _vm._v(\" TMSP: \"),\n          _c(\"a\", { attrs: { href: \"https://github.com/tendermint/tmsp\" } }, [\n            _vm._v(\"https://github.com/tendermint/tmsp\"),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            { attrs: { href: \"https://github.com/ethereum/EIPs/issues/53\" } },\n            [_vm._v(\"18\")]\n          ),\n          _vm._v(\" Ethereum Sharding: \"),\n          _c(\n            \"a\",\n            { attrs: { href: \"https://github.com/ethereum/EIPs/issues/53\" } },\n            [_vm._v(\"https://github.com/ethereum/EIPs/issues/53\")]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"http://www.ds.ewi.tudelft.nl/fileadmin/pds/papers/PerformanceAnalysisOfLibswift.pdf\",\n              },\n            },\n            [_vm._v(\"19\")]\n          ),\n          _vm._v(\" LibSwift: \"),\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"http://www.ds.ewi.tudelft.nl/fileadmin/pds/papers/PerformanceAnalysisOfLibswift.pdf\",\n              },\n            },\n            [\n              _vm._v(\n                \"http://www.ds.ewi.tudelft.nl/fileadmin/pds/papers/PerformanceAnalysisOfLibswift.pdf\"\n              ),\n            ]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf\",\n              },\n            },\n            [_vm._v(\"20\")]\n          ),\n          _vm._v(\" DLS: \"),\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf\",\n              },\n            },\n            [_vm._v(\"http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf\")]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://en.bitcoin.it/wiki/Thin_Client_Security\",\n              },\n            },\n            [_vm._v(\"21\")]\n          ),\n          _vm._v(\" Thin Client Security: \"),\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://en.bitcoin.it/wiki/Thin_Client_Security\",\n              },\n            },\n            [_vm._v(\"https://en.bitcoin.it/wiki/Thin_Client_Security\")]\n          ),\n        ]),\n        _c(\"li\", [\n          _c(\n            \"a\",\n            { attrs: { href: \"http://vitalik.ca/files/mauve_paper.html\" } },\n            [_vm._v(\"22\")]\n          ),\n          _vm._v(\" Ethereum 2.0 Mauve Paper: \"),\n          _c(\n            \"a\",\n            { attrs: { href: \"http://vitalik.ca/files/mauve_paper.html\" } },\n            [_vm._v(\"http://vitalik.ca/files/mauve_paper.html\")]\n          ),\n        ]),\n      ]),\n      _c(\"h4\", { attrs: { id: \"links-nao-classificados\" } }, [\n        _vm._v(\"Links não classificados\"),\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\n            \"a\",\n            {\n              attrs: {\n                href: \"https://www.docdroid.net/ec7xGzs/314477721-ethereum-platform-review-opportunities-and-challenges-for-private-and-consortium-blockchains.pdf.html\",\n              },\n            },\n            [\n              _vm._v(\n                \"https://www.docdroid.net/ec7xGzs/314477721-ethereum-platform-review-opportunities-and-challenges-for-private-and-consortium-blockchains.pdf.html\"\n              ),\n            ]\n          ),\n        ]),\n      ]),\n    ])\n  },\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}